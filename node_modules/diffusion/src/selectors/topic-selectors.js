"use strict";
/**
 * @module diffusion.selectors
 */
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var topic_selector_parser_1 = require("topics/topic-selector-parser");
var topic_selector_1 = require("./topic-selector");
/**
 * Create {@link TopicSelector} instances for use with other API methods.
 *
 * Selectors are evaluated against topic paths. A topic path is a '/'
 * separated string of parts, which map to the topic hierarchy. Each part is
 * formed of one or more UTF characters, except '/'. Topic paths are absolute,
 * and evaluated from the root of the current domain.
 *
 * **Example:**
 * ```
 * // Create a topic selector
 * var selector = diffusion.selectors.parse('?foo/bar/.*');
 * ```
 */
var TopicSelectors = /** @class */ (function () {
    function TopicSelectors() {
        /**
         * The Prefix enum
         */ // tslint:disable-next-line:variable-name
        this.Prefix = topic_selector_1.Prefix;
        /**
         * The Type enum
         */ // tslint:disable-next-line:variable-name
        this.Type = topic_selector_1.Type;
    }
    /**
     * Parse an expression to create a selector.
     *
     * This function can take any number of arguments. Each argument can be a string
     * or a {@link TopicSelector}. Alternatively, an array of strings and
     * {@link TopicSelector}s can be passed as a single argument.
     *
     * The following types of expression are supported. The type is determined
     * by the first character of the expression.
     *
     * <dl>
     * <dt>Path
     * <dd>Path expressions begin with the character <code>></code>. The remainder of
     * the expression must be a valid topic path. A topic path is a '/'
     * separated string of parts. Each part is formed of one or more UTF
     * characters, except '/'.
     *
     * A {@link Type.PATH PATH} selector is returned that only
     * selects the topic with the given path.
     *
     * <h4>Abbreviated Path Expressions</h4>
     *
     * In Diffusion 5.2, an alternative syntax for path expressions was added.
     * An <em>abbreviated path expression</em> is any valid topic path (see
     * above) that begins with a character other than one of <code>#</code>,
     * <code>?</code>, <code>></code>, <code>*</code>, <code>$</code>,
     * <code>%</code>, <code>&</code>, or <code><</code>.
     * This syntax allows most topic paths to be used directly as selector
     * expressions which appears more natural.
     *
     * This method converts abbreviated path expressions to standard path
     * expressions by prepending the <code>></code> character. Thus <code>a/b</code> is
     * interpreted as <code>>a/b</code>.
     *
     * <code>parse("a/b").expression</code> will return <code>">a/b"</code>.
     *
     * <dt>Split-path pattern
     * <dd>Split-path pattern expressions begin with the character <code>?</code>.
     * The remainder of the expression is split into a list of regular
     * expressions using the <code>/</code> character as a separator.
     *
     * A {@link Type.SPLIT_PATH_PATTERN SPLIT_PATH_PATTERN}
     * selector is returned that selects topics for which each regular
     * expression matches each part of the topic path at the corresponding
     * level.
     *
     * <dt>Full-path pattern
     * <dd>Full-path pattern expressions begin with the character <code>*</code>. The
     * remainder of the pattern is a regular expression.
     *
     * A {@link Type.FULL_PATH_PATTERN FULL_PATH_PATTERN} selector
     * is returned that selects topics for which the regular expression matches
     * the complete topic path.
     *
     * Full-path patterns provide a lot of expressive power but should be used
     * sparingly since the server can evaluate split-path patterns more
     * efficiently.
     *
     * Selector sets are the preferred way to combine expressions.
     * <code>parse("a", "b")</code> is equivalent to the full-path expression "
     * <code>*[a|b]</code>", but can be evaluated more efficiently by the
     * server.
     *
     * <dt>Selector set
     * <dd>Selector set expressions begin with the character <code>#</code>. The
     * remainder of the expression is a list of contained selectors, formatted
     * as described below.
     *
     * A {@link Type.SELECTOR_SET SELECTOR_SET} selector is
     * returned that selects topics that match any of the contained selectors.
     *
     * The contained selectors are formatted as follows. First, any selector
     * sets are expanded to produce a full list of non-selector set expressions.
     * Then the selector expressions are concatenated, separated by the
     * separator <code>////</code>. This separator has been chosen as it is not
     * valid in a path, and is not a useful sequence in a pattern.
     * </dl>
     *
     * <h2>Descendant pattern qualifiers</h2>
     *
     * Split-path and full-path pattern expressions can be further modified by
     * appending `/` or `//`. These control the behaviour of the
     * selector with respect to the descendants of the topics that match the
     * pattern.
     *
     * <ul>
     *
     * <li>
     * If the expression does not end with `/` or `//`, it selects
     * only the topics that match the pattern.</li>
     *
     * <li>
     * If the expression ends with `/`, it selects only the descendants of
     * the matching topics, excluding the matching topics.</li>
     *
     * <li>
     * If the expression ends with `//`, it selects the matching topics
     * and all of their descendants.</li>
     * </ul>
     * </p>
     *
     * <h2>Regular expressions</h2>
     *
     * Any Java-style regular expression can be used in split-path and full-path
     * patterns, with the following restrictions:
     *
     * * A regular expression may not be empty.
     * * A regular expression used in split-path patterns may not contain the
     *   path separator `/`.
     * * A regular expression used in full-path patterns may not contain the
     *   selector set separator `////`.
     *
     * Regular expressions that break any of these restrictions would never
     * match a topic path, so they make no practical difference.
     *
     * <h2>Examples</h2>
     *
     * <h3>Path expressions</h3>
     *
     *  Path         |  Matches `alpha/beta`? | Matches `alpha/beta/gamma`?
     * ------------- | ---------------------- | ---------------------------
     * `>alpha/beta`       | yes | no
     * `>alpha/beta/gamma` | no  | yes
     * `>beta`             | no  | no
     * `>.*``/.*`          | no  | no
     * `>/alpha/beta/`     | yes | no
     *
     * <h3>Abbreviated path expressions</h3>
     *
     *  Path         |  Matches `alpha/beta`? | Matches `alpha/beta/gamma`?
     * ------------- | ---------------------- | ---------------------------
     * `alpha/beta`        | yes | no
     * `alpha/beta/gamma`  | no  | yes
     * `beta`              | no  | no
     * `/alpha/beta/`      | yes | no
     *
     * <h3>Split-path pattern expressions</h3>
     *
     *  Path         |  Matches `alpha/beta`? | Matches `alpha/beta/gamma`?
     * ------------- | ---------------------- | ---------------------------
     * `?alpha/beta`       | yes | no
     * `?alpha/beta/gamma` | no  | yes
     * `?beta`             | no  | no
     * `?.*`               | no  | no
     * `?.*``/.*`          | yes | no
     * `?alpha/beta/`      | no  | yes
     * `?alpha/beta//`     | yes | yes
     * `?alpha/.*``//`     | yes | yes
     *
     * <h3>Full-path pattern expressions</h3>
     *
     *  Path         |  Matches `alpha/beta`? | Matches `alpha/beta/gamma`?
     * ------------- | ---------------------- | ---------------------------
     * `*alpha/beta`       | yes | no
     * `*alpha/beta/gamma` | no  | yes
     * `*beta`             | no  | no
     * `*.*beta`           | yes | no
     * `*.*`               | yes | yes
     * `*alpha/beta/`      | no  | yes
     * `*alpha/beta//`     | yes | yes
     *
     * **Example:**
     * ```
     * // Simple selector
     * var selector = diffusion.selectors.parse(">a/b");
     * ```
     *
     * **Example:**
     * ```
     * // Creating a selector set
     * var selectorSet = diffusion.selectors.parse(">a", ">b");
     * ```
     *
     * @param expression  the pattern expression(s). At least one
     *                    valid selector has to be specified.
     * @param args        additional pattern expressions
     * @return            the topic selector. If multiple expressions are provided,
     *                    this will return a `SELECTOR_SET` that will match if
     *                    any of the * provided `selectors` match.
     */
    TopicSelectors.prototype.parse = function (expression) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return topic_selector_parser_1.parseSelector.apply(void 0, __spread([expression], args));
    };
    return TopicSelectors;
}());
exports.TopicSelectors = TopicSelectors;
