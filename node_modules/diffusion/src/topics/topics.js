"use strict";
/**
 * Provide access to {@link TopicType TopicType},
 * {@link TopicSpecification TopicSpecification}, and
 * {@link UnsubscribeReason UnsubscribeReason}
 * @namespace diffusion.topics
 *
 * @module diffusion.topics
 */
Object.defineProperty(exports, "__esModule", { value: true });
var enumerize_1 = require("util/enumerize");
var fetch_request_1 = require("./fetch-request");
var topic_specification_1 = require("./topic-specification");
var topic_type_1 = require("./topic-type");
/**
 * A type containing information about the reason for an unsubscription
 */
var UnsubscribeReason = /** @class */ (function () {
    /**
     * Create a `UnsubscribeReason`
     *
     * @param  id      the unsubscribe reason's id
     * @param  reason  the unsubscribe reason's description
     */
    function UnsubscribeReason(id, reason) {
        this.id = id;
        this.reason = reason;
    }
    return UnsubscribeReason;
}());
exports.UnsubscribeReason = UnsubscribeReason;
/**
 * Enum containing reasons that an unsubscription occurred.
 *
 * **Example:**
 * ```
 * // Use UnsubscribeReason to validate unsubscription notifications
 * session.addStream('>foo', diffusion.datatypes.string())
 *        .on('unsubscribe', function(topic, specification, reason) {
 *     switch (reason) {
 *         case diffusion.topics.UnsubscribeReason.REMOVED :
 *             // Do something if the topic was removed
 *         default :
 *             // Do something else if the client was explicitly unsubscribed
 *     }
 * });
 * ```
 */ // tslint:disable-next-line:variable-name
exports.UnsubscribeReasonEnum = {
    /**
     * The server has re-subscribed this session to the topic. Existing
     * streams are unsubscribed because the topic type and other attributes
     * may have changed.
     *
     * This can happen if a set of servers are configured to use session
     * replication, and the session connected to one server reconnects
     * ('fails over') to a different server.
     *
     * A stream that receives an unsubscription notification with this
     * reason will also receive a subscription notification with the new
     * {@link TopicSpecification}.
     *
     * @since 5.9
     */
    SUBSCRIPTION_REFRESH: new UnsubscribeReason(undefined, 'The server has re-subscribed this session'),
    /**
     * A fallback stream has been unsubscribed or subscribed due to the
     * addition or removal of a stream that selects the topic.
     *
     * @since 5.9
     */
    STREAM_CHANGE: new UnsubscribeReason(undefined, 'A more specific stream has been registered to the same path'),
    /**
     * The unsubscription was requested by this client.
     */
    REQUESTED: new UnsubscribeReason(0, 'The unsubscription was requested by this client'),
    /**
     * The server or another client unsubscribed this client.
     */
    CONTROL: new UnsubscribeReason(1, 'The server or another client unsubscribed this client'),
    /**
     * The topic was removed
     */
    REMOVED: new UnsubscribeReason(2, 'The topic was removed'),
    /**
     * The unsubscription occurred because the session is no longer authorized to access the topic.
     * @since 5.9
     */
    AUTHORIZATION: new UnsubscribeReason(3, 'Not authorized to subscribe to this topic'),
    /**
     * A reason that is unsupported by the session.
     *
     * @since 6.1
     */
    UNKNOWN_UNSUBSCRIBE_REASON: new UnsubscribeReason(4, 'Unknown unsubscribe reason'),
    /**
     * The server has a significant backlog of messages for the session, and
     * the topic specification has the {@link TopicSpecification.CONFLATION
     * conflation topic property} set to 'unsubscribe'. The session can
     * resubscribe to the topic. The unsubscription is not persisted to the
     * cluster. If the session fails over to a different server it will be
     * resubscribed to the topic.
     *
     * @since 6.1
     */
    BACK_PRESSURE: new UnsubscribeReason(5, 'The server has unsubscribed due to a backlog of messages')
};
enumerize_1.enumerize(exports.UnsubscribeReasonEnum);
Object.freeze(exports.UnsubscribeReasonEnum);
/**
 * A type containing information about the reason for failure of an update
 */
var UpdateFailReason = /** @class */ (function () {
    /**
     * Create a `UpdateFailReason`
     *
     * @param  id      the update fail reason's id
     * @param  reason  the update fail reason's description
     */
    function UpdateFailReason(id, reason) {
        this.id = id;
        this.reason = reason;
    }
    return UpdateFailReason;
}());
exports.UpdateFailReason = UpdateFailReason;
/**
 * The reason that a topic could not be updated.
 *
 * **Example:**
 * ```
 * session.topics.update('foo', 'bar').then(function() { ... }, function(err) {
 *     switch (err) {
 *         case diffusion.topics.UpdateFailReason.MISSING_TOPIC:
 *             ...
 *         case diffusion.topics.UpdateFailReason.EXCLUSIVE_UPDATER_CONFLICT:
 *             ...
 *     }
 * });
 * ```
 */ // tslint:disable-next-line:variable-name
exports.UpdateFailReasonEnum = {
    /**
     * The update was of a type that is not compatible with the topic it was submitted for, or
     * the topic does not support updating.
     */
    INCOMPATIBLE_UPDATE: new UpdateFailReason(1, 'Update type is incompatible with topic type'),
    /**
     * The update failed, possibly because the content sent with the update was invalid/incompatible with topic type or
     * data format.
     */
    UPDATE_FAILED: new UpdateFailReason(2, 'Update failed - possible content incompatibility'),
    /**
     * The updater used is not active.
     */
    INVALID_UPDATER: new UpdateFailReason(3, 'Updater is invalid for updating'),
    /**
     * The topic being updated does not exist.
     */
    MISSING_TOPIC: new UpdateFailReason(4, 'Topic does not exist'),
    /**
     * Attempt to perform a non-exclusive update to a topic branch that already has an update source registered to it.
     */
    EXCLUSIVE_UPDATER_CONFLICT: new UpdateFailReason(7, 'An exclusive update source is already registered for the topic branch'),
    /**
     * An attempt has been made to apply a delta to a topic that has not yet has a value specified for it.
     */
    DELTA_WITHOUT_VALUE: new UpdateFailReason(8, 'An attempt has been made to apply a delta to a topic that does not yet have a value'),
    /**
     * An update to a replicated topic failed because the cluster was
     * repartitioning due to a server starting, stopping, or failing. The
     * session can retry the operation.
     */
    CLUSTER_REPARTITION: new UpdateFailReason(9, 'When trying to update the topic the cluster was migrating the partition that owns the topic'),
    /**
     * An update could not be performed because the topic is managed by a
     * component (e.g fan-out) that prohibits updates from the caller.
     */
    INCOMPATIBLE_STATE: new UpdateFailReason(10, 'An update could not be performed because the topic is managed by' +
        'a component (e.g fan-out) that prohibits updates from the caller'),
    /**
     * An update was not performed because the constraint was not satisfied.
     */
    UNSATISFIED_CONSTRAINT: new UpdateFailReason(-1, 'The topic update failed because the constraint was not satisfied'),
    /**
     * An update to a replicated topic failed because the cluster was
     * repartitioning due to a server starting, stopping, or failing. The
     * session can retry the operation.
     */
    INVALID_UPDATE_STREAM: new UpdateFailReason(-2, 'The topic update failed because the update stream is no longer valid'),
};
enumerize_1.enumerize(exports.UpdateFailReasonEnum);
Object.freeze(exports.UpdateFailReasonEnum);
/**
 * A type containing information about the reason for failure of adding a topic
 */
var TopicAddFailReason = /** @class */ (function () {
    /**
     * Create a `TopicAddFailReason`
     *
     * @param  id      the topic add failure reason's id
     * @param  reason  the topic add failure reason's description
     */
    function TopicAddFailReason(id, reason) {
        this.id = id;
        this.reason = reason;
    }
    return TopicAddFailReason;
}());
exports.TopicAddFailReason = TopicAddFailReason;
/**
 * The reason that a topic could not be added.
 *
 * **Example:**
 * ```
 * session.topics.add('foo').then(function() { ... }, function(err) {
 *     switch (err) {
 *          case diffusion.topics.TopicAddFailReason.EXISTS:
 *              ...
 *          case diffusion.topics.TopicAddFailReason.INVALID_PATH:
 *              ...
 *     }
 * });
 * ```
 *
 */ // tslint:disable-next-line:variable-name
exports.TopicAddFailReasonEnum = {
    /**
     * The topic already exists with the same details.
     */
    EXISTS: new TopicAddFailReason(1, 'The topic already exists with the same details'),
    /**
     * The topic already exists, with different details.
     */
    EXISTS_MISMATCH: new TopicAddFailReason(2, 'The topic already exists, with different details'),
    /**
     * The topic path is invalid.
     */
    INVALID_PATH: new TopicAddFailReason(3, 'The topic path is invalid'),
    /**
     * The topic details are invalid.
     */
    INVALID_DETAILS: new TopicAddFailReason(4, 'The topic details are invalid'),
    /**
     * A user supplied class could not be found or instantiated.
     * <b>Deprecation notice</b>
     *
     * This value is associated only with removed methods that create topics.
     * It will be removed in a future release.
     *
     * @deprecated Since 6.2
     */
    USER_CODE_ERROR: new TopicAddFailReason(5, 'A user supplied class could not be found or instantiated'),
    /**
     * A referenced topic could not be found.
     */
    TOPIC_NOT_FOUND: new TopicAddFailReason(6, 'A referenced topic could not be found'),
    /**
     * Invalid permissions to add a topic at the specified path.
     */
    PERMISSIONS_FAILURE: new TopicAddFailReason(7, 'Invalid permissions to add a topic at the specified path'),
    /**
     * The topic could not be initialised, supplied value may be of the wrong format.
     * <b>Deprecation notice</b>
     *
     * This value is associated only with removed methods that
     * allow the specification of an initial value when creating a
     * topic. It will be removed in a future release.
     *
     * @deprecated Since 6.1
     */
    INITIALISE_ERROR: new TopicAddFailReason(8, 'The topic could not be initialised, supplied value may be of the wrong format'),
    /**
     *  An unexpected error occured while creating the topic.
     */
    UNEXPECTED_ERROR: new TopicAddFailReason(9, 'An unexpected error occured while creating the topic'),
    /**
     * When trying to create the topic the cluster was migrating the partition
     * that owns the topic. The correct owner could not be identified and the
     * request failed. This is a transient failure for the duration of the
     * partition migration.
     */
    CLUSTER_REPARTITION: new TopicAddFailReason(10, 'When trying to create the topic the cluster was migrating the partition that owns the topic'),
    /**
     * Adding the topic failed because of a license limit.
     */
    EXCEEDED_LICENSE_LIMIT: new TopicAddFailReason(11, 'Adding the topic failed because of a license limit'),
    /**
     * Adding the topic failed because an incompatible topic owned is already bound to the parent path.
     *
     * @deprecated Since 6.5
     *             <p>
     *             This value is no longer used and will be removed in a future release.
     */
    INCOMPATIBLE_PARENT: new TopicAddFailReason(12, 'Adding the topic failed because an incompatible topic is already bound to the parent path'),
    /**
     * Adding a slave topic failed because an incompatible topic is
     * already bound to the specified master path.
     *
     * @deprecated Since 6.4
     *             <p>
     *             Slave topics are deprecated. Since 6.5, this value is used will be removed in a
     *             future release.
     */
    INCOMPATIBLE_MASTER: new TopicAddFailReason(13, 'Adding a slave topic failed because an incompatible topic ' +
        'is already bound to the specified master path.'),
    /**
     * Adding the topic failed because a topic is already bound to the specified
     * path but the caller does not have the rights to manage it.
     *
     * This can be because the topic is being managed by a component with
     * exclusive control over the topic, such as fan-out and thus
     * the caller will not be able to update or remove the topic.
     *
     * If the caller has suitable permissions then it could still subscribe to
     * the topic, but the topic's specification may be different from that
     * requested.
     */
    EXISTS_INCOMPATIBLE: new TopicAddFailReason(14, 'Adding the topic failed because a topic is already bound to the specified' +
        'path but the caller does not have the rights to manage it'),
    /**
     * The supplied topic path is invalid.
     */
    INVALID_NAME: new TopicAddFailReason(15, 'The supplied topic path is invalid.'),
};
enumerize_1.enumerize(exports.TopicAddFailReasonEnum);
Object.freeze(exports.TopicAddFailReasonEnum);
exports.topicsNamespace = {
    FetchRequest: fetch_request_1.FetchRequest,
    TopicType: topic_type_1.TopicTypeEnum,
    TopicSpecification: topic_specification_1.TopicSpecification,
    UnsubscribeReason: exports.UnsubscribeReasonEnum,
    UpdateFailReason: exports.UpdateFailReasonEnum,
    TopicAddFailReason: exports.TopicAddFailReasonEnum
};
