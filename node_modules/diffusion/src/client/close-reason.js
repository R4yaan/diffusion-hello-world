"use strict";
/**
 * @module diffusion.clients
 */
Object.defineProperty(exports, "__esModule", { value: true });
var close_reason_1 = require("client/close-reason");
var enumerize_1 = require("util/enumerize");
/**
 * Enum representing the reason that the session has been closed.
 *
 * **Example:**
 * ```
 * diffusion.connect({...}).then(function(session) {...}, function(err) {
 *   switch(err) {
 *       case diffusion.clients.CloseReason.CLOSED_BY_CLIENT:
 *       // Do something
 *       case diffusion.clients.CloseReason.ACCESS_DENIED:
 *       // Do something else
 *       ...
 *   }
 * });
 * ```
 *
 */ // tslint:disable-next-line:variable-name
exports.CloseReasonEnum = {
    /**
     * The client requested close. Not recoverable.
     */
    CLOSED_BY_CLIENT: new close_reason_1.CloseReasonImpl(0, 'The session was closed by the client', false),
    /**
     * The session has been closed by the server, or another session using the
     * {@link ClientControl} feature.
     */
    CLOSED_BY_SERVER: new close_reason_1.CloseReasonImpl(1, 'The session was closed by the server', false),
    /**
     * Whilst disconnected, the client explicitly aborted a reconnect attempt.
     */
    RECONNECT_ABORTED: new close_reason_1.CloseReasonImpl(2, 'Client aborted a reconnect attempt', false),
    /**
     * The connection attempt timed out, waiting for a response from the server.
     *
     * The reconnection timeout can be controlled by the {@link
     * Options.reconnect reconnect} options.
     */
    CONNECTION_TIMEOUT: new close_reason_1.CloseReasonImpl(3, 'The connection attempt timed out', false),
    /**
     * The connection handshake was rejected by the server.
     *
     * The server responded with an unknown error code when the client attempted
     * to connect.
     */
    HANDSHAKE_REJECTED: new close_reason_1.CloseReasonImpl(4, 'The connection handshake was rejected by the server', false),
    /**
     * There was an error parsing the handshake response.
     *
     * The client received a handshake response from the server but the response
     * was malformed and could not be deserialised.
     */
    HANDSHAKE_ERROR: new close_reason_1.CloseReasonImpl(5, 'There was an error parsing the handshake response', false),
    /**
     * There was an unexpected error with the network connection.
     *
     * The underlying transport (Websocket, XHR) received an error that could
     * not be handled.
     */
    TRANSPORT_ERROR: new close_reason_1.CloseReasonImpl(6, 'There was an unexpected error with the connection', true),
    /**
     * The client could not establish a connection to the server.
     *
     * An error was thrown while the client was attempting to connect to the
     * server.
     */
    CONNECTION_ERROR: new close_reason_1.CloseReasonImpl(7, 'The client could not establish a connection to the server', true),
    /**
     * The client detected that the connection was idle.
     *
     * The client has not received a ping message from the server for an
     * extended period of time.
     */
    IDLE_CONNECTION: new close_reason_1.CloseReasonImpl(8, 'The activity monitor detected the connection was idle', true),
    /**
     * Loss of messages from the client has been detected. For example,
     * whilst waiting for the arrival of missing messages in a sequence of
     * messages a timeout has occurred.
     *
     * HTTP based transports use multiple TCP connections. This can cause
     * the messages to be received out of order. To reorder the messages
     * those sent to the server may contain a sequence number indicating the
     * correct order.
     *
     * If a message is received out of order there is a short time for the
     * earlier messages to be received. If the messages are not received in
     * this time the client is closed.
     *
     * Missing, invalid or duplicate sequence numbers will also close the
     * client for this reason.
     *
     * This cannot be recovered from as the client and the server are in
     * inconsistent states.
     */
    LOST_MESSAGES: new close_reason_1.CloseReasonImpl(16, 'Loss of messages has been detected', false),
    /**
     * The handshake response contained an incompatible protocol version.
     *
     * The server does not support the client's protocol version.
     */
    PROTOCOL_VERSION_MISMATCH: new close_reason_1.CloseReasonImpl(17, 'There was a mismatch in the protocol versions', false),
    /**
     * The connection request was rejected because the license limit was reached.
     */
    LICENSE_EXCEEDED: new close_reason_1.CloseReasonImpl(18, 'The license limit was exceeded', false),
    /**
     * The connection attempt failed due to a security restraint or due to
     * invalid credentials.
     */
    ACCESS_DENIED: new close_reason_1.CloseReasonImpl(99, 'The connection attempt was rejected by the server because authentication failed', false)
};
enumerize_1.enumerize(exports.CloseReasonEnum);
