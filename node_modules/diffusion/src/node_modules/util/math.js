"use strict";
/**
 * @module Util.Math
 *
 * @brief Mathenatical utility functions
 */
/* tslint:disable:no-bitwise */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Calculate the number of leading zeros in the binary representation of a number
 * using the minimal amount of bit-shifting
 *
 * @param  i the number to analyse
 * @return   the number of leading binary zeros
 */
function leadingZeros(i) {
    if (i === 0) {
        return 32;
    }
    var n = 1;
    if (i >>> 16 === 0) {
        n += 16;
        i <<= 16;
    }
    if (i >>> 24 === 0) {
        n += 8;
        i <<= 8;
    }
    if (i >>> 28 === 0) {
        n += 4;
        i <<= 4;
    }
    if (i >>> 30 === 0) {
        n += 2;
        i <<= 2;
    }
    n -= i >>> 31;
    return n;
}
/**
 * Cheap approximation to a square root.
 *
 * @param value the argument of the square-root function
 * @return      a power of two that approximates the square root of a value
 */
function approximateSquareRoot(value) {
    if (value < 0) {
        throw new Error('Value must be great or equal to 0');
    }
    if (value === 0) {
        return 0;
    }
    var h = 32 - leadingZeros(value);
    return 1 << Math.round(h / 2);
}
exports.approximateSquareRoot = approximateSquareRoot;
/**
 * Find the next integer, equal or higher to the value, which is a power of two.
 *
 * @param value the value to search from
 * @returns     the next power of two
 */
function findNextPowerOfTwo(value) {
    if (value < 0 || value > 1 << 30) {
        throw new Error('Illegal argument: ' + value);
    }
    // see: https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
    value--;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value++;
    return value;
}
exports.findNextPowerOfTwo = findNextPowerOfTwo;
/**
 * Converts an integer conforming to IEEE 754 Single bit format to a floating
 * point value. This is similar to Java's Float#intBitsToFloat.
 *
 * See https://en.wikipedia.org/wiki/Single-precision_floating-point_format for
 * detail on the bit layout.
 *
 * Code taken from http://stackoverflow.com/a/16001019 - most succinct
 * implementation I could find that avoided unnecessary loops or reads.
 *
 * @param bytes integer containing IEEE-754 value bytes
 * @returns     the resulting float
 */
function intBitsToFloat(bytes) {
    var sign = (bytes & 0x80000000) ? -1 : 1;
    var exponent = ((bytes >> 23) & 0xFF) - 127;
    var significand = (bytes & ~(-1 << 23));
    if (exponent === 128) {
        return sign * ((significand) ? Number.NaN : Number.POSITIVE_INFINITY);
    }
    if (exponent === -127) {
        if (significand === 0) {
            return sign * 0.0;
        }
        exponent = -126;
        significand /= (1 << 22);
    }
    else {
        significand = (significand | (1 << 23)) / (1 << 23);
    }
    return sign * significand * Math.pow(2, exponent);
}
exports.intBitsToFloat = intBitsToFloat;
/**
 * Maximum 32 bit integer value: 2^32 - 1
 */
exports.MAX_INT32 = 2147483647;
/**
 * Maximum safe integer value for JavaScript numbers: 2^53 - 1
 */
exports.MAX_SAFE_INTEGER = 9007199254740991;
