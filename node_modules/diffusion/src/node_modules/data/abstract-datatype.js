"use strict";
/**
 * @module diffusion.datatypes
 */
Object.defineProperty(exports, "__esModule", { value: true });
var any_datatype_1 = require("data/any-datatype");
var binary_delta_impl_1 = require("data/binary/binary-delta-impl");
var binary_delta_type_impl_1 = require("data/binary/binary-delta-type-impl");
var bytes_impl_1 = require("data/bytes-impl");
/**
 * An abstract implementation of the {@link DataType} interface
 *
 * @param <ValueType>   the value type of the data type
 * @param <SourceType>  the type(s) from which a value can be constructed
 * @param <CBORType>    the binary type containing the CBOR data
 */
var AbstractDataType = /** @class */ (function () {
    /**
     * Create a new instance of `AbstractDataType`
     *
     * @param typeName          the data type name
     * @param valueClass        the constructor function creating the value type
     * @param implementation    a constructor function that creates the binary CBOR representation
     * @param vToC              a converter function that converts a value to binary CBOR data
     * @param cToV              a converter function that converts the binary CBOR data to a value
     * @param converters        an array of constructor functions. These will be added to the
     *                          {@link valueConverters} map. Each constructor must implement
     *                          a static `toString` function.
     * @param withBinaryDelta   a flag indicating if the data type supports binary deltas
     */
    function AbstractDataType(typeName, valueClass, implementation, vToC, cToV, converters, withBinaryDelta) {
        var _this = this;
        /**
         * A map of value converters
         *
         * Value converters convert binary data containing the CBOR value into a
         * different value type.
         *
         * The key of the map is a string representation of the destination type.
         */
        this.valueConverters = {};
        this.typeName = typeName;
        this.cToV = cToV;
        this.vToC = vToC;
        this.implementation = implementation;
        converters.forEach(function (impl) {
            _this.valueConverters[impl.toString()] = function (buffer, offset, length) {
                return new impl(buffer, offset, length);
            };
        });
        this.valueConverters[bytes_impl_1.BytesImpl.toString()] = function (buffer, offset, length) {
            return new bytes_impl_1.BytesImpl(buffer, offset, length);
        };
        this.valueConverters[valueClass.toString()] = this.readValue.bind(this);
        this.valueConverters[any_datatype_1.AnyDataTypeImpl.toString()] = this.readValue.bind(this);
        this.valueClass = valueClass;
        if (withBinaryDelta) {
            this.binaryDeltaTypeImpl
                = new binary_delta_type_impl_1.BinaryDeltaTypeImpl(implementation, vToC, cToV);
        }
    }
    /**
     * @inheritdoc
     */
    AbstractDataType.prototype.name = function () {
        return this.typeName;
    };
    /**
     * Convert the objet to a string
     *
     * @return  a string representation of the AbstractDataType
     */
    AbstractDataType.prototype.toString = function () {
        return this.typeName + " data type";
    };
    /**
     * @inheritdoc
     */
    AbstractDataType.prototype.writeValue = function (value) {
        var internal = this.vToC(value);
        if (internal === null) {
            throw new Error(this + " cannot write " + value);
        }
        return internal.asBuffer();
    };
    /**
     * Convert a value to bytes
     *
     * @param value  the value
     * @return       a CBOR representation of the value
     * @throws       an error if the supplied value could not be converted
     */
    AbstractDataType.prototype.toBytes = function (value) {
        var bytes = this.vToC(value);
        if (bytes) {
            return bytes;
        }
        throw new Error(this + " cannot convert value to Bytes: " + value);
    };
    /**
     * @inheritdoc
     */
    AbstractDataType.prototype.readValue = function (buffer, offset, length) {
        if (buffer instanceof bytes_impl_1.BytesImpl) {
            if (buffer instanceof this.implementation) {
                return this.cToV(buffer);
            }
            return this.readValue(buffer.$buffer, buffer.$offset, buffer.$length);
        }
        return this.cToV(new this.implementation(buffer, offset, length));
    };
    /**
     * @inheritdoc
     */
    AbstractDataType.prototype.canReadAs = function (valueClass) {
        // tslint:disable-next-line:strict-type-predicates
        return this.valueConverters[valueClass.toString()] !== undefined;
    };
    /**
     * @inheritdoc
     */
    AbstractDataType.prototype.readAs = function (valueClass, buffer, offset, length) {
        if (buffer instanceof bytes_impl_1.BytesImpl) {
            return this.readAs(valueClass, buffer.$buffer, buffer.$offset, buffer.$length);
        }
        if (this.valueConverters[valueClass.toString()]) {
            return this.valueConverters[valueClass.toString()](buffer, offset, length);
        }
        throw new Error(this + " is incompatible with values of " + valueClass);
    };
    /**
     * @inheritdoc
     */
    AbstractDataType.prototype.deltaType = function (name) {
        if (!name || name === 'binary' || name instanceof binary_delta_impl_1.BinaryDeltaImpl) {
            return this.binaryDeltaType();
        }
        throw new Error(this + " has no '" + name + "' delta type");
    };
    /**
     * The binary delta type
     *
     * @returns      the delta type
     */
    AbstractDataType.prototype.binaryDeltaType = function () {
        if (this.binaryDeltaTypeImpl === undefined) {
            throw new Error(this + " has no binary delta type");
        }
        return this.binaryDeltaTypeImpl;
    };
    return AbstractDataType;
}());
exports.AbstractDataType = AbstractDataType;
