"use strict";
/**
 * @module diffusion.datatypes.RecordV2
 */
Object.defineProperty(exports, "__esModule", { value: true });
var library_1 = require("core-js/library");
/**
 * A Record V2 field type
 */
var Type;
(function (Type) {
    Type["DECIMAL"] = "DECIMAL";
    Type["INTEGER"] = "INTEGER";
    Type["STRING"] = "STRING";
})(Type = exports.Type || (exports.Type = {}));
/**
 * A Record V2 field schema entry
 */
var FieldImpl = /** @class */ (function () {
    /**
     * Create a new field
     *
     * @param  name   the name of the field
     * @param  type   the datatype of the field
     * @param  min    the minimum number of occurrences of the node within its parent
     * @param  max    the maximum number of occurrences of the node within its parent
     * @param  index  the index of the field
     * @param  scale  an optional scale for decimal field types
     */
    function FieldImpl(name, type, min, max, index, scale) {
        this.name = name;
        this.type = type;
        this.min = min;
        this.max = max;
        this.scale = scale;
        this.index = index;
        this.isVariable = min !== max;
    }
    /**
     * Calculate the absolute index of the field
     *
     * @param  index  the index offset
     * @return        the absolute index
     * @throws        an error if the index offset is out of range
     */
    FieldImpl.prototype.getAbsoluteIndex = function (index) {
        if (index < 0 || this.max !== -1 && index > this.max - 1) {
            throw new Error("Invalid index '" + index + "' for field '" + this.name + "'");
        }
        return this.index + index;
    };
    /**
     * Convert the field to a string
     *
     * @return  a string representation of the field
     */
    FieldImpl.prototype.toString = function () {
        var ret = "Name=" + this.name + ", Type=" + this.type;
        if (this.min === this.max) {
            ret += ", Occurs=" + this.min;
        }
        else {
            ret += ", Min=" + this.min + ", Max=";
            if (this.max === -1) {
                ret += 'Unlimited';
            }
            else {
                ret += this.max;
            }
        }
        if (this.type === Type.DECIMAL) {
            ret += ", Scale=" + this.scale;
        }
        return "Field [" + ret + "]";
    };
    /**
     * Returns a model string representation of the field's data type.
     *
     * @return       the zero value or empty string formatted according to the data
     *               type
     */
    FieldImpl.prototype.modelValue = function () {
        switch (this.type) {
            case Type.DECIMAL:
                return decimalModelValue(this);
            case Type.INTEGER:
                return '0';
            case Type.STRING:
            default:
                return '';
        }
    };
    /**
     * Convert the field schema to a raw data object
     *
     * @return  a data object that can be serialised into a JSON string
     */
    FieldImpl.prototype.toJSON = function () {
        var o = {
            name: this.name,
            type: this.type,
            min: this.min,
            max: this.max
        };
        if (this.type === Type.DECIMAL) {
            o.scale = this.scale;
        }
        return o;
    };
    return FieldImpl;
}());
exports.FieldImpl = FieldImpl;
/**
 * Returns a validated value in the format indicated by the field
 *
 * @param field  the field providing the type information
 * @param value  the value to convert
 * @return       a string representation of the value
 */
function normalise(field, value) {
    switch (field.type) {
        case Type.DECIMAL:
            var f = parseFloat(value);
            if (library_1.Number.isNaN(f)) {
                throw new Error("Invalid decimal value: '" + value + "'");
            }
            return f.toFixed(field.scale);
        case Type.INTEGER:
            var i = parseInt(value, 10);
            var s = i.toString();
            if (library_1.Number.isNaN(i) || s.indexOf('.') > -1) {
                throw new Error("Invalid integer value: '" + value + "'");
            }
            return s;
        case Type.STRING:
            return value;
        default:
            return '';
    }
}
exports.normalise = normalise;
/**
 * Returns a model string representation of the field's data type for the
 * decimal type.
 *
 * @param field  the field providing the type information
 * @return       the zero value formatted according to the data type and scale
 */
function decimalModelValue(field) {
    switch (field.scale) {
        case undefined:
        case 1:
            return '0.0';
        case 2:
            return '0.00';
        case 3:
            return '0.000';
        default:
            var ret = '0.';
            for (var i = 0; i < field.scale; ++i) {
                ret += '0';
            }
            return ret;
    }
}
