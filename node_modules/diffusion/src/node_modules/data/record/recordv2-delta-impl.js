"use strict";
/**
 * @module diffusion.datatypes.RecordV2
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var bytes_impl_1 = require("data/bytes-impl");
var recordv2_parser_1 = require("data/record/recordv2-parser");
var recordv2_utils_1 = require("data/record/recordv2-utils");
/**
 * A {@link RecordV2Delta} that indicates no change between two {@link
 * diffusion.datatypes.RecordV2} values
 */
var NoChange = /** @class */ (function (_super) {
    __extends(NoChange, _super);
    /**
     * Create a NoChange instance
     */
    function NoChange() {
        return _super.call(this, Buffer.from([])) || this;
    }
    /**
     * Returns a list of the changes.
     *
     * @return an empty change list
     */
    NoChange.prototype.changes = function () {
        return [];
    };
    return NoChange;
}(bytes_impl_1.BytesImpl));
exports.NoChange = NoChange;
/**
 * Instance of the {@link NoChange} RecordV2 delta
 */
exports.NO_CHANGE = new NoChange();
/**
 * An enum indicating the type of a change
 */
var Type;
(function (Type) {
    Type["FIELD_CHANGED"] = "FIELD_CHANGED";
    Type["FIELDS_ADDED"] = "FIELDS_ADDED";
    Type["FIELDS_REMOVED"] = "FIELDS_REMOVED";
    Type["RECORDS_ADDED"] = "RECORDS_ADDED";
    Type["RECORDS_REMOVED"] = "RECORDS_REMOVED";
})(Type = exports.Type || (exports.Type = {}));
/**
 * Implementation of the {@link Change} interface representing a single change
 * to a Record value
 */
var ChangeImpl = /** @class */ (function () {
    /**
     * Create a ChangeImpl instance
     *
     * @param  type         string denoting the type of change that this represents
     * @param  recordName   the name of the affected record
     * @param  recordIndex  the index of the affected record
     * @param  fieldName    the name of the affected field
     * @param  fieldIndex   the index of the affected field
     */
    function ChangeImpl(type, recordName, recordIndex, fieldName, fieldIndex) {
        this.type = type;
        this.recordName = recordName;
        this.recordIndex = recordIndex;
        this.fieldName = fieldName;
        this.fieldIndex = fieldIndex;
        var key = recordName + "(" + recordIndex + ")";
        if (type !== Type.RECORDS_REMOVED && type !== Type.RECORDS_ADDED) {
            key += "." + fieldName + "(" + fieldIndex + ")";
        }
        this.key = key;
    }
    ChangeImpl.prototype.toString = function () {
        return this.type + " " + this.key;
    };
    return ChangeImpl;
}());
exports.ChangeImpl = ChangeImpl;
/**
 * Implementation of {@link RecordV2Delta}
 */
var RecordV2DeltaImpl = /** @class */ (function (_super) {
    __extends(RecordV2DeltaImpl, _super);
    /**
     * Create a RecordV2DeltaImpl instance
     *
     * @param  buffer  the internal buffer
     * @param  offset  the offset of the slice
     * @param  length  the number of bytes in the slice
     * @param  recordChanges  an array containing a record index at position 0
     *                        and a boolean at position 1 indicating if a record
     *                        has changed
     * @param  fieldChanges   an array of arrays containing a field index at
     *                        position 0 and a boolean at position 1 indicating
     *                        which fields have changed
     */
    function RecordV2DeltaImpl(buffer, offset, length, recordChanges, fieldChanges) {
        if (offset === void 0) { offset = 0; }
        if (length === void 0) { length = buffer.length; }
        var _this = _super.call(this, buffer, offset, length) || this;
        _this.recordChanges = recordChanges;
        _this.fieldChanges = fieldChanges;
        return _this;
    }
    /**
     * @inheritdoc
     */
    RecordV2DeltaImpl.prototype.changes = function (schema) {
        var _this = this;
        var data = recordv2_parser_1.parse(this.$buffer, this.$offset, this.$length);
        var recordIndex = 0;
        var changes = [];
        schema.records().forEach(function (schemaRecord) {
            if (data.length < recordIndex + schemaRecord.min) {
                throw new Error("Insufficient records of type " + schemaRecord.name + " in delta for schema");
            }
            if (schemaRecord.isVariable) {
                recordIndex = _this.processVariableRecordChanges(schemaRecord, recordIndex, data, changes);
            }
            else {
                recordIndex = _this.processFixedRecordChanges(schemaRecord, recordIndex, data, changes);
            }
        });
        return changes;
    };
    /**
     * Process changes in a fixed multiplicity record
     *
     * @param  schemaRecord  the schema definition of the record
     * @param  startIndex    the start index of the record to process
     * @param  data          the record data
     * @param  changes       the change list in which to record the changes
     * @return               the next record index to process
     */
    RecordV2DeltaImpl.prototype.processFixedRecordChanges = function (schemaRecord, startIndex, data, changes) {
        var recordIndex = startIndex;
        for (var i = 0; i < schemaRecord.min; ++i) {
            this.processRecordChanges(recordIndex, schemaRecord, i, data[recordIndex], changes);
            recordIndex++;
        }
        return recordIndex;
    };
    /**
     * Process changes in a variable multiplicity record
     *
     * @param  schemaRecord  the schema definition of the record
     * @param  startIndex    the start index of the record to process
     * @param  data          the record data
     * @param  changes       the change list in which to record the changes
     * @return               the next record index to process
     */
    RecordV2DeltaImpl.prototype.processVariableRecordChanges = function (schemaRecord, startIndex, data, changes) {
        var numberOfNewRecords = data.length;
        var maxAllowed = schemaRecord.max;
        if (maxAllowed !== -1 && numberOfNewRecords > startIndex + maxAllowed) {
            throw new Error("Too many records of type " + schemaRecord.name + " in delta for schema");
        }
        var recordIndex = startIndex;
        var matchRecordCount = (this.recordChanges && this.recordChanges[0])
            ? this.recordChanges[1]
            : numberOfNewRecords;
        for (var varIndex = 0; recordIndex < matchRecordCount; recordIndex++, varIndex++) {
            this.processRecordChanges(recordIndex, schemaRecord, varIndex, data[recordIndex], changes);
        }
        if (this.recordChanges) {
            changes.push(new ChangeImpl(this.recordChanges[0] ? Type.RECORDS_ADDED : Type.RECORDS_REMOVED, schemaRecord.name, this.recordChanges[1] - startIndex, '', 0));
        }
        return recordIndex;
    };
    /**
     * Process changes in a single record entry
     *
     * @param  dataRecordIndex  the global index of the record to process
     * @param  schemaRecord     the schema definition of the record
     * @param  recordIndex      the local index of the record to process
     * @param  data             the record data
     * @param  changes          the change list in which to record the changes
     */
    RecordV2DeltaImpl.prototype.processRecordChanges = function (dataRecordIndex, record, recordIndex, data, changes) {
        var _this = this;
        var fieldIndex = 0;
        record.fields.forEach(function (field) {
            if (field.isVariable) {
                fieldIndex = _this.processVariableFieldChanges(record, recordIndex, dataRecordIndex, field, fieldIndex, data, changes);
            }
            else {
                fieldIndex = _this.processFixedFieldChanges(record, recordIndex, field, fieldIndex, data, changes);
            }
        });
    };
    /**
     * Process changes in a fixed multiplicity field
     *
     * @param  record       the schema definition of the record
     * @param  recordIndex  the local index of the record to process
     * @param  field        the schema definition of the field
     * @param  startIndex   the start index of the field to process
     * @param  data         the record data
     * @param  changes      the change list in which to record the changes
     * @return              the next field index to process
     */
    RecordV2DeltaImpl.prototype.processFixedFieldChanges = function (record, recordIndex, field, startIndex, data, changes) {
        var numberOfFields = data.length;
        var fieldIndex = startIndex;
        for (var i = 0; i < field.min; ++i) {
            if (fieldIndex >= numberOfFields) {
                throw new Error("Insufficient fields of type " + field.name + " in delta for schema record " + record.name);
            }
            if (data[fieldIndex] !== '') {
                changes.push(new ChangeImpl(Type.FIELD_CHANGED, record.name, recordIndex, field.name, i));
            }
            fieldIndex++;
        }
        return fieldIndex;
    };
    /**
     * Process changes in a varable multiplicity field
     *
     * @param  record           the schema definition of the record
     * @param  recordIndex      the local index of the record to process
     * @param  dataRecordIndex  the global index of the record to process
     * @param  field            the schema definition of the field
     * @param  startIndex       the start index of the field to process
     * @param  data             the record data
     * @param  changes          the change list in which to record the changes
     * @return                  the next field index to process
     */
    RecordV2DeltaImpl.prototype.processVariableFieldChanges = function (record, recordIndex, dataRecordIndex, field, startIndex, data, changes) {
        var numberOfFields = data.length;
        var fieldIndex = startIndex;
        if (numberOfFields < fieldIndex + field.min) {
            throw new Error("Insufficient fields of type " + field.name + " in delta for schema record " + record.name);
        }
        var fChanges = this.fieldChanges[dataRecordIndex];
        var matchingFieldCount = fChanges ? fChanges[1] : numberOfFields;
        for (var varIndex = 0; fieldIndex < matchingFieldCount; fieldIndex++, varIndex++) {
            if (data[fieldIndex] !== '') {
                changes.push(new ChangeImpl(Type.FIELD_CHANGED, record.name, recordIndex, field.name, varIndex));
            }
        }
        if (fChanges) {
            changes.push(new ChangeImpl(fChanges[0] ? Type.FIELDS_ADDED : Type.FIELDS_REMOVED, record.name, recordIndex, field.name, fChanges[1]));
        }
        return fieldIndex;
    };
    /**
     * Convert the RecordV2DeltaImpl to a string
     *
     * @return  a string representation of the buffer data
     */
    RecordV2DeltaImpl.prototype.toString = function () {
        return recordv2_utils_1.bytesToString(this.$buffer, this.$offset, this.$length);
    };
    return RecordV2DeltaImpl;
}(bytes_impl_1.BytesImpl));
exports.RecordV2DeltaImpl = RecordV2DeltaImpl;
