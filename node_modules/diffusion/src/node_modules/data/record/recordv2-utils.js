"use strict";
/**
 * @module diffusion.datatypes.RecordV2
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Delimiter byte for records
 */
exports.RECORD_DELIMITER = 0x1;
/**
 * Delimiter byte for fields
 */
exports.FIELD_DELIMITER = 0x2;
/**
 * Byte indicating an empty field
 */
exports.EMPTY_FIELD = 0x3;
/**
 * Byte indicating a single record
 */
exports.RECORD_MU = 0x4;
/**
 * Byte indicating a single field
 */
exports.FIELD_MU = 0x5;
/**
 * String representation of a delimiter byte for records
 */
exports.RECORD_DELIMITER_STRING = String.fromCharCode(exports.RECORD_DELIMITER);
/**
 * String representation of a delimiter byte for fields
 */
exports.FIELD_DELIMITER_STRING = String.fromCharCode(exports.FIELD_DELIMITER);
/**
 * String representation of a byte indicating an empty field
 */
exports.EMPTY_FIELD_STRING = String.fromCharCode(exports.EMPTY_FIELD);
/**
 * String representation of a byte indicating a single record
 */
exports.RECORD_MU_STRING = String.fromCharCode(exports.RECORD_MU);
/**
 * String representation of a byte indicating a single field
 */
exports.FIELD_MU_STRING = String.fromCharCode(exports.FIELD_MU);
/**
 * Convert a buffer or array of bytes containing Record V2 data into a string
 *
 * @param  bytes   the bytes to convert
 * @param  offset  the starting position in the buffer
 * @param  length  the number of bytes to convert
 * @return         a string representation of the bytes
 */
function bytesToString(bytes, offset, length) {
    var ret = '';
    for (var i = offset; i < offset + length; ++i) {
        switch (bytes[i]) {
            case exports.FIELD_DELIMITER:
                ret += '<FD>';
                break;
            case exports.RECORD_DELIMITER:
                ret += '<RD>';
                break;
            case exports.EMPTY_FIELD:
                ret += '<EF>';
                break;
            case exports.FIELD_MU:
                ret += '<FM>';
                break;
            case exports.RECORD_MU:
                ret += '<RM>';
                break;
            default:
                ret += String.fromCharCode(bytes[i]);
        }
    }
    return ret;
}
exports.bytesToString = bytesToString;
/**
 * Count the number of records or fields in the raw Record V2 data
 *
 * @param  bytes      the bytes to check
 * @param  offset     the starting position in the buffer
 * @param  length     the number of bytes to convert
 * @param  mu         the token indicating an empty set
 * @param  delimiter  the token separating two entities
 * @return            the number of records in the data
 */
function entityCount(bytes, offset, length, mu, delimiter) {
    if (length === 0) {
        return 0;
    }
    if (bytes[0] === mu) {
        return 1;
    }
    var count = 1;
    for (var i = offset; i < offset + length; i++) {
        if (bytes[i] === delimiter) {
            count++;
        }
    }
    return count;
}
/**
 * Count the number of records in the raw Record V2 data
 *
 * @param  bytes   the bytes to check
 * @param  offset  the starting position in the buffer
 * @param  length  the number of bytes to convert
 * @return         the number of records in the data
 */
function recordCount(bytes, offset, length) {
    return entityCount(bytes, offset, length, exports.RECORD_MU, exports.RECORD_DELIMITER);
}
exports.recordCount = recordCount;
/**
 * Count the number of fields in the raw Record V2 data
 *
 * @param  bytes   the bytes to check
 * @param  offset  the starting position in the buffer
 * @param  length  the number of bytes to convert
 * @return         the number of fields in the data
 */
function fieldCount(bytes, offset, length) {
    return entityCount(bytes, offset, length, exports.FIELD_MU, exports.FIELD_DELIMITER);
}
exports.fieldCount = fieldCount;
/**
 * Find a delimiter in the raw Record V2 data. Returns the position of the
 * within the range [`startIndex`, `endIndex`). If the delimiter is not found,
 * `endIndex` will be returned.
 *
 * @param  bytes       the bytes to check
 * @param  startIndex  the first index to begin searching
 * @param  endIndex    the last index to stop searching
 * @param  delimiter   the delimiter to search for
 * @return             the index of the delimiter
 */
function findDelimiter(bytes, startIndex, endIndex, delimiter) {
    for (var pos = startIndex; pos < endIndex; pos++) {
        if (bytes[pos] === delimiter) {
            return pos;
        }
    }
    return endIndex;
}
exports.findDelimiter = findDelimiter;
/**
 * Checks if the data contains a single empty record
 *
 * @param  bytes   the bytes to check
 * @param  offset  the starting position in the buffer
 * @param  length  the number of bytes to convert
 * @return         `true` if the data contains a single empty record
 */
function isSingleEmptyRecord(bytes, offset, length) {
    return length === 1 && bytes[offset] === exports.RECORD_MU;
}
exports.isSingleEmptyRecord = isSingleEmptyRecord;
/**
 * Checks if the data contains a single empty field
 *
 * @param  bytes   the bytes to check
 * @param  offset  the starting position in the buffer
 * @param  length  the number of bytes to convert
 * @return         `true` if the data contains a single empty field
 */
function recordIsSingleEmptyField(bytes, offset, length) {
    return length === 1 && (bytes[offset] === exports.FIELD_MU || bytes[offset] === exports.EMPTY_FIELD);
}
exports.recordIsSingleEmptyField = recordIsSingleEmptyField;
