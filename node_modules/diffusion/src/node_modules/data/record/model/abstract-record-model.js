"use strict";
/**
 * @module diffusion.datatypes.RecordV2
 */
Object.defineProperty(exports, "__esModule", { value: true });
var RecordV2Writer = require("data/record/recordv2-writer");
/**
 * Get the absolute index of a record in the schema
 *
 * @param  record  the record to inspect
 * @param  records the array of records that contains the record
 * @param  index   an index offset
 * @return         the absolute index of the record in the schema
 * @throws         a error if the index is not found
 */
function resolveRecordIndex(record, records, index) {
    var actualIndex = record.getAbsoluteIndex(index);
    if (actualIndex > records.length - 1) {
        throw new Error("Index '" + index + "' does not have a matching entry for variable occurrence record: '" + record.name + "'");
    }
    return actualIndex;
}
exports.resolveRecordIndex = resolveRecordIndex;
/**
 * Get the absolute index of a field in the schema
 *
 * @param  field   the field to inspect
 * @param  fields  the array of field that contains the record
 * @param  index   an index offset
 * @return         the absolute index of the field in the schema
 * @throws         a error if the index is not found
 */
function resolveFieldIndex(field, fields, index) {
    var actualIndex = field.getAbsoluteIndex(index);
    if (actualIndex > fields.length - 1) {
        throw new Error("Index '" + index + "' does not have a matching entry for variable occurrence field: '" + field.name + "'");
    }
    return actualIndex;
}
exports.resolveFieldIndex = resolveFieldIndex;
/**
 * Abstract base class for {@link RecordModelImpl} and {@link
 * MutableRecordModelImpl}.
 *
 * This class implements all methods of the {@link RecordModel} interface but
 * introduces the abstract {@link AbstractRecordModel.model model} method. *
 */
var AbstractRecordModel = /** @class */ (function () {
    /**
     * Create an AbstractRecordModel
     *
     * @param recordV2Constructor  a constructor function for creating {@link RecordV2} implementations
     * @param schema               the schema that this model corresponds to
     */
    function AbstractRecordModel(recordV2Constructor, schema) {
        this.recordV2Constructor = recordV2Constructor;
        this.modelSchema = schema;
    }
    /**
     * Get the schema that this model corresponds to
     */
    AbstractRecordModel.prototype.schema = function () {
        return this.modelSchema;
    };
    /**
     * @inheritdoc
     */
    AbstractRecordModel.prototype.asValue = function () {
        return new this.recordV2Constructor(RecordV2Writer.toBuffer(this.model()));
    };
    /**
     * @inheritdoc
     */
    AbstractRecordModel.prototype.get = function (recordName, recordIndexOrFieldName, fieldNameOrFieldIndex, fieldIndex) {
        if (recordIndexOrFieldName === void 0) { recordIndexOrFieldName = 0; }
        if (fieldIndex === void 0) { fieldIndex = 0; }
        var fieldName;
        var recordIndex;
        switch (arguments.length) {
            case 1:
                var key = this.parseKey(recordName);
                recordName = key.recordName;
                recordIndex = key.recordIndex;
                fieldName = key.fieldName;
                fieldIndex = key.fieldIndex;
                break;
            case 2:
                fieldName = recordIndexOrFieldName;
                recordIndex = 0;
                break;
            default:
                fieldName = fieldNameOrFieldIndex;
                recordIndex = recordIndexOrFieldName;
        }
        var schemaRecord = this.modelSchema.getRecord(recordName);
        var schemaField = schemaRecord.getField(fieldName);
        var record = this.getRecord(schemaRecord, recordIndex);
        return record[resolveFieldIndex(schemaField, record, fieldIndex)];
    };
    /**
     * @inheritdoc
     */
    AbstractRecordModel.prototype.recordCount = function (recordName) {
        var schemaRecord = this.modelSchema.getRecord(recordName);
        if (schemaRecord.isVariable) {
            return this.model().length - schemaRecord.getIndex();
        }
        else {
            return schemaRecord.min;
        }
    };
    /**
     * @inheritdoc
     */
    AbstractRecordModel.prototype.fieldCount = function (recordName, recordIndex, fieldName) {
        var schemaRecord = this.modelSchema.getRecord(recordName);
        var schemaField = schemaRecord.getField(fieldName);
        if (schemaField.isVariable) {
            var record = this.getRecord(schemaRecord, recordIndex);
            return record.length - schemaField.getIndex();
        }
        else {
            return schemaField.min;
        }
    };
    /**
     * Get the model data for a record
     *
     * @param schemaRecord  the record for which to get the data
     * @param index         the index of the record
     * @return              model data of the record
     */
    AbstractRecordModel.prototype.getRecord = function (schemaRecord, index) {
        var model = this.model();
        return model[resolveRecordIndex(schemaRecord, model, index)];
    };
    /**
     * Convert a textual representation of a record entry to a record key
     *
     * @param key  the key string
     * @return     the parsed record key
     */
    AbstractRecordModel.prototype.parseKey = function (key) {
        var parts = key.split('.', 2);
        var recordName;
        var recordIndex;
        var fieldKey;
        if (parts.length === 1) {
            recordName = this.modelSchema.firstRecord().name;
            recordIndex = 0;
            fieldKey = parts[0];
        }
        else {
            var recordKeyParts = this.parseKeyPart(parts[0].trim());
            recordName = recordKeyParts[0];
            recordIndex = recordKeyParts[1];
            fieldKey = parts[1];
        }
        var keyParts = this.parseKeyPart(fieldKey);
        return {
            recordName: recordName,
            recordIndex: recordIndex,
            fieldName: keyParts[0],
            fieldIndex: keyParts[1]
        };
    };
    /**
     * Parse the field name and index part of a record key
     *
     * @param  keyPart  the part of the key containing the field name and index
     * @return          an array containing the field name and the field index
     */
    AbstractRecordModel.prototype.parseKeyPart = function (keyPart) {
        if (keyPart.length === 0) {
            throw new Error('No name specified');
        }
        var openIndex = keyPart.indexOf('(');
        if (openIndex === -1) {
            return [keyPart, 0];
        }
        if (openIndex === 0) {
            throw new Error('No name specified');
        }
        var closeIndex = keyPart.indexOf(')');
        if (closeIndex === -1 || closeIndex < openIndex) {
            throw new Error('\'(\' found without closing \')');
        }
        if (closeIndex < keyPart.length - 1) {
            throw new Error('Characters found after closing \')');
        }
        return [keyPart.substring(0, openIndex), parseInt(keyPart.substring(openIndex + 1, closeIndex), 10)];
    };
    return AbstractRecordModel;
}());
exports.AbstractRecordModel = AbstractRecordModel;
