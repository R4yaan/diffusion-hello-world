"use strict";
/**
 * @module diffusion.datatypes
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var P16 = 1 << 16;
var P24 = 1 << 24;
var P32 = P16 * P16;
/**
 * Store a 32 bit integer in the buffer
 *
 * @param  value   the 32 bit integer to store
 * @param  buffer  the buffer to write into
 * @param  high    a flag indicating whether to store the integer in the high or
 *                 the low bits of the buffer
 */
function putInt32(value, buffer, high) {
    var offset = high ? 0 : 4;
    for (var i = 3; i >= 0; --i) {
        buffer[offset + i] = value & 255;
        value = value >> 8;
    }
}
/**
 * Read a 32 bit integer from the buffer
 *
 * @param  buffer  the buffer to write into
 * @param  high    a flag indicating whether to read the high or
 *                 the low bits of the buffer
 * @return         the integer that was read from the buffer
 */
function getInt32(buffer, high) {
    var offset = high ? 0 : 4;
    return (buffer[offset] * P24) +
        (buffer[offset + 1] << 16) +
        (buffer[offset + 2] << 8) +
        buffer[offset + 3];
}
/**
 * Store a positive number in the buffer
 *
 * @param  value   the number` to store
 * @param  buffer  the buffer to write into
 */
function putPositiveNumber(value, buffer) {
    for (var i = 7; i >= 0; --i) {
        buffer[i] = value & 255;
        value /= 256;
    }
}
/**
 * Store a negative number in the buffer
 *
 * @param  value   the number` to store
 * @param  buffer  the buffer to write into
 */
function putNegativeNumber(value, buffer) {
    value++;
    for (var i = 7; i >= 0; --i) {
        buffer[i] = ((-value) & 255) ^ 255;
        value /= 256;
    }
}
/**
 * Store an integer represented by a string in the buffer
 *
 * @param  value   the string containing the number to store
 * @param  radix   the radix of the number representation
 * @param  buffer  the buffer to write into
 */
function putString(value, radix, buffer) {
    var e_1, _a;
    var negative = value[0] === '-';
    if (negative) {
        value = value.substring(1);
    }
    else if (value.substring(0, 2) === '0x') {
        value = value.substring(2);
        radix = 16;
    }
    var high = 0;
    var low = 0;
    try {
        for (var value_1 = __values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
            var char = value_1_1.value;
            low = low * radix + parseInt(char, radix);
            high = high * radix + Math.floor(low / P32);
            low %= P32;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (value_1_1 && !value_1_1.done && (_a = value_1.return)) _a.call(value_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (negative) {
        high = ~high;
        if (low) {
            low = P32 - low;
        }
        else {
            high++;
        }
    }
    putInt32(high, buffer, true);
    putInt32(low, buffer, false);
}
/**
 * Implementation of signed 64-bit integer. May be constructed from a buffer, string or number.
 */
var Int64Impl = /** @class */ (function () {
    /**
     * Create a new Int64Impl instance
     *
     * @param  value  the value of the integer
     * @param  radix  if `value` is a string the represents the radix and
     *                defaults to 10. If value is a number, this represents the
     *                optional low bits of the number.           description
     */
    function Int64Impl(value, radix) {
        this.buffer = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]);
        if (Buffer.isBuffer(value)) {
            this.buffer = value;
        }
        if (typeof value === 'string') {
            radix = radix || 10;
            putString(value, radix, this.buffer);
        }
        if (typeof value === 'number') {
            // explicit high/low bits
            if (typeof radix === 'number') {
                putInt32(value, this.buffer, true);
                putInt32(radix, this.buffer, false);
            }
            else if (value >= 0) {
                putPositiveNumber(value, this.buffer);
            }
            else {
                putNegativeNumber(value, this.buffer);
            }
        }
        if (value instanceof Int64Impl) {
            putInt32(value.getHighBits(), this.buffer, true);
            putInt32(value.getLowBits(), this.buffer, false);
        }
    }
    /**
     * Return the name of the data type
     *
     * @return `Int64Impl`
     */
    Int64Impl.toString = function () {
        return 'Int64Impl';
    };
    /**
     * Get the high bits of the integer
     *
     * @return the high bits of the number
     */
    Int64Impl.prototype.getHighBits = function () {
        return getInt32(this.buffer, true);
    };
    /**
     * Get the low bits of the integer
     *
     * @return the low bits of the number
     */
    Int64Impl.prototype.getLowBits = function () {
        return getInt32(this.buffer, false);
    };
    /**
     * Get the integer stored in a buffer
     *
     * @return  the internal buffer
     */
    Int64Impl.prototype.toBuffer = function () {
        return this.buffer;
    };
    /**
     * @inheritdoc
     */
    Int64Impl.prototype.toNumber = function () {
        var high = this.getHighBits() | 0;
        var low = this.getLowBits();
        // this is a lossy operation - see docs. Will be accurate for numbers up to 2 ^ 53
        return high ? high * P32 + low : low;
    };
    /**
     * Check is the number is negative
     *
     * @return  `true` if the integer is negative
     */
    Int64Impl.prototype.isNegative = function () {
        return !!(this.getHighBits() & 0x80000000);
    };
    /**
     * @inheritdoc
     */
    Int64Impl.prototype.toString = function (radix) {
        if (radix === void 0) { radix = 10; }
        var high = this.getHighBits();
        var low = this.getLowBits();
        var sign = this.isNegative();
        if (sign) {
            high = ~high;
            low = P32 - low;
        }
        if (high === 0 && low === 0) {
            return '0';
        }
        var result = '';
        while (high || low) {
            // multiply modulo remainder up to its 'real' value (since it
            // represents the top 32 bits of a single value)
            var rem = (high % radix) * P32 + low;
            // divide by radix, essentially reducing the high/low values by the
            // digits we've taken from the modulo remainder. We can't use
            // bitwise operations to coerce to integer, as that would truncate
            // to 32 bits
            high = Math.floor(high / radix);
            low = Math.floor(rem / radix);
            result = (rem % radix).toString(radix) + result;
        }
        if (sign) {
            result = '-' + result;
        }
        return result;
    };
    /**
     * Check if the number is equal to another object
     *
     * @return  `true` if the other object is an Int64Impl containing the same
     *          data
     */
    Int64Impl.prototype.equals = function (other) {
        if (other && other instanceof Int64Impl) {
            return this.getHighBits() === other.getHighBits() && this.getLowBits() === other.getLowBits();
        }
        return false;
    };
    return Int64Impl;
}());
exports.Int64Impl = Int64Impl;
