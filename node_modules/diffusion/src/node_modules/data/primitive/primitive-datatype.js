"use strict";
/**
 * @module diffusion.datatypes
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var decoder_1 = require("cbor/decoder");
var encoder_1 = require("cbor/encoder");
var abstract_datatype_1 = require("data/abstract-datatype");
var bytes_impl_1 = require("data/bytes-impl");
var json_impl_1 = require("data/json/json-impl");
var encoder = new encoder_1.Encoder();
var NULL_CBOR = new bytes_impl_1.BytesImpl(Buffer.from([0xf6]));
/**
 * The primitive data type acts as the base class for primitive value types
 * `string`, `double`, and `Int64`.
 *
 * @param <ValueType>   the value type of the data type
 * @param <SourceType>  the type(s) from which a value can be constructed
 */
var PrimitiveDataType = /** @class */ (function (_super) {
    __extends(PrimitiveDataType, _super);
    /**
     * Create a new instance of `PrimitiveDataType`
     *
     * @param typeName           the data type name
     * @param valueClass         the constructor function creating the value type
     * @param serialise          serialise the value into a CBOR encoder
     * @param cborTypePredicate  a predicate returning `true` if the CBOR type is
     *                           supported by this data type.
     * @param withBinaryDelta    a flag indicating if the data type supports binary deltas
     */
    function PrimitiveDataType(typeName, valueClass, serialise, cborTypePredicate, withBinaryDelta) {
        var _this = this;
        var vToC = function (value) {
            serialise(value, encoder);
            return new bytes_impl_1.BytesImpl(encoder.flush());
        };
        var cToV = function (bytes) {
            if (NULL_CBOR.equals(bytes)) {
                return null;
            }
            var decoder = new decoder_1.Decoder(bytes.$buffer, bytes.$offset, bytes.$length);
            return decoder.nextValueExpecting(cborTypePredicate);
        };
        _this = _super.call(this, typeName, valueClass, bytes_impl_1.BytesImpl, vToC, cToV, [json_impl_1.JSONImpl], withBinaryDelta) || this;
        _this.serialise = serialise;
        _this.fromValue = vToC;
        return _this;
    }
    /**
     * @inheritdoc
     */
    PrimitiveDataType.prototype.writeValue = function (value) {
        if (value === null || value === undefined) {
            return NULL_CBOR.asBuffer();
        }
        else {
            this.serialise(value, encoder);
            return encoder.flush();
        }
    };
    /**
     * @inheritdoc
     */
    PrimitiveDataType.prototype.validate = function () {
        // no-op. This data type validates on read.
    };
    /**
     * Create a new Bytes instance from data
     *
     * @param value  the value or CBOR data containing the record
     * @return       a new Binary representation of the value
     */
    PrimitiveDataType.prototype.from = function (value) {
        if (value.$buffer) {
            return value;
        }
        else {
            return this.fromValue(value);
        }
    };
    return PrimitiveDataType;
}(abstract_datatype_1.AbstractDataType));
exports.PrimitiveDataType = PrimitiveDataType;
