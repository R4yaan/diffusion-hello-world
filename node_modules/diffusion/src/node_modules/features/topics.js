"use strict";
/**
 * @module Topics
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var close_reason_1 = require("client/close-reason");
var library_1 = require("core-js/library");
var datatypes_1 = require("data/datatypes");
var emitter_1 = require("events/emitter");
var stream_1 = require("events/stream");
var fetch_request_1 = require("features/topics/fetch-request");
var fetch_stream_1 = require("features/topics/fetch-stream");
var ValueStreamProxy = require("features/topics/value-stream-proxy");
var Services = require("services/services");
var topic_selector_parser_1 = require("topics/topic-selector-parser");
var logger = require("util/logger");
var require_non_null_1 = require("util/require-non-null");
var log = logger.create('Session');
/**
 * Implementation of the {@link Topics} feature
 *
 * {@link TopicsImpl} extends {@link StreamImpl} so that {@link SessionImpl}
 * can extend directly from {@link TopicsImpl} without the need for multiple
 * inheritance.
 */
var TopicsImpl = /** @class */ (function (_super) {
    __extends(TopicsImpl, _super);
    /**
     * Create a new TopicsImpl instance
     *
     * @param internal  the internal session
     */
    function TopicsImpl(internal, helper, events) {
        var _this = _super.call(this, helper, events) || this;
        _this.internal = internal;
        _this.UNSUBSCRIBE = internal.getServiceLocator().obtain(Services.UNSUBSCRIBE);
        _this.SUBSCRIBE = internal.getServiceLocator().obtain(Services.SUBSCRIBE);
        _this.FETCH = internal.getServiceLocator().obtain(Services.FETCH);
        _this.streamRegistry = internal.getStreamRegistry();
        return _this;
    }
    /**
     * @inheritdoc
     */
    TopicsImpl.prototype.unsubscribe = function (topic) {
        var _this = this;
        var selectors = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            selectors[_i - 1] = arguments[_i];
        }
        var args = arguments;
        return new library_1.Promise(function (resolve, reject) {
            try {
                var selector = (args.length > 1)
                    ? topic_selector_parser_1.parseSelector(Array.prototype.slice.call(args))
                    : topic_selector_parser_1.parseSelector(topic);
                if (_this.internal.checkConnected(reject)) {
                    var unsubscribeCallback = function (err) {
                        if (err) {
                            log.debug('Unsubscribe failed', topic);
                            reject(err);
                        }
                        else {
                            log.debug('Unsubscribe complete', topic);
                            resolve();
                        }
                    };
                    log.debug('Unsubscribing', topic);
                    _this.UNSUBSCRIBE.send(selector, unsubscribeCallback);
                }
            }
            catch (err) {
                reject(err);
            }
        });
    };
    /**
     * @inheritdoc
     */
    TopicsImpl.prototype.fetch = function (topic) {
        var selectors = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            selectors[_i - 1] = arguments[_i];
        }
        log.debug('Fetch request for: ', topic);
        if (this.internal.isShared()) {
            throw new Error('Deprecated fetch is not implemented for shared sessions');
        }
        require_non_null_1.requireNonNull(topic, 'Selector');
        var factory = emitter_1.Emitter.create();
        var stream = new fetch_stream_1.FetchStreamImpl(factory);
        var emitter = factory.emitter(stream);
        try {
            var selector = (arguments.length > 1)
                ? topic_selector_parser_1.parseSelector(Array.prototype.slice.call(arguments))
                : topic_selector_parser_1.parseSelector(topic);
            var reject = function (err) {
                emitter.error(err);
            };
            if (this.internal.checkConnected(reject)) {
                var cid = this.internal.getConversationSet().newConversation({
                    onOpen: function () {
                        emitter.emit('open');
                    },
                    onResponse: function (conversationId, message) {
                        var content = message.data;
                        var path = message.topic;
                        if (path) {
                            emitter.emit('value', content, path);
                            return false;
                        }
                        else if (content.length === 1 && content[0] === 1) {
                            emitter.close();
                            return true;
                        }
                        else {
                            emitter.error(new Error('Unexpected end of fetch stream'));
                            return true;
                        }
                    },
                    onDiscard: function (conversationId, reason) {
                        if (reason instanceof close_reason_1.CloseReasonImpl) {
                            emitter.close();
                        }
                        else {
                            emitter.error(reason);
                        }
                    }
                });
                this.FETCH.send({
                    cid: cid,
                    selector: selector
                }, function (err) {
                    if (err) {
                        emitter.error(err);
                    }
                });
            }
        }
        catch (err) {
            emitter.error(err);
        }
        return stream;
    };
    /**
     * @inheritdoc
     */
    TopicsImpl.prototype.fetchRequest = function () {
        return new fetch_request_1.FetchRequestImpl(this.internal);
    };
    /**
     * @inheritdoc
     */
    TopicsImpl.prototype.select = function (topic) {
        var _this = this;
        var selectors = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            selectors[_i - 1] = arguments[_i];
        }
        var args = arguments;
        return new library_1.Promise(function (resolve, reject) {
            log.debug('Subscribing', topic);
            try {
                var selector = (args.length > 1)
                    ? topic_selector_parser_1.parseSelector(Array.prototype.slice.call(args))
                    : topic_selector_parser_1.parseSelector(topic);
                if (_this.internal.checkConnected(reject)) {
                    _this.SUBSCRIBE.send(selector, function (err) {
                        if (!err) {
                            resolve();
                        }
                        else {
                            reject(err);
                        }
                    });
                }
            }
            catch (err) {
                reject(err);
            }
        });
    };
    /**
     * @inheritdoc
     */
    TopicsImpl.prototype.addStream = function (topic, datatype) {
        if (arguments.length !== 2) {
            throw new Error('Both topic selector and value type are needed');
        }
        if (!datatype || datatypes_1.DataTypes.get(datatype)) {
            throw new Error('Data type required');
        }
        var selector = topic_selector_parser_1.parseSelector(topic);
        return ValueStreamProxy.create(this.streamRegistry, datatype, false, selector);
    };
    /**
     * @inheritdoc
     */
    TopicsImpl.prototype.addFallbackStream = function (datatype) {
        if (!datatype || datatypes_1.DataTypes.get(datatype)) {
            throw new Error('Data type required');
        }
        return ValueStreamProxy.create(this.streamRegistry, datatype, true);
    };
    return TopicsImpl;
}(stream_1.StreamImpl));
exports.TopicsImpl = TopicsImpl;
