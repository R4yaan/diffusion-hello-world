"use strict";
/**
 * @module TopicControl
 */
Object.defineProperty(exports, "__esModule", { value: true });
var close_reason_1 = require("client/close-reason");
var library_1 = require("core-js/library");
var datatypes_1 = require("data/datatypes");
var update_source_state_1 = require("features/topic-control/update-source-state");
var Services = require("services/services");
var topic_path_utils_1 = require("topics/topic-path-utils");
var topic_selector_parser_1 = require("topics/topic-selector-parser");
var topics_1 = require("../../topics/topics");
/**
 * Convert a buffer slice to a buffer
 *
 * @param d  the buffer slice
 * @return   the buffer
 */
function dataToBytes(d) {
    return d.$buffer.slice(d.$offset, d.$length);
}
/**
 * Clear a value cache using a topic selector in a string
 *
 * @param cache  the value cache
 * @param path   the topic path
 */
function clearCache(cache, path) {
    var selector = topic_selector_parser_1.parseSelector('?' + topic_path_utils_1.canonicalise(path) + '//');
    cache.remove(selector);
}
/**
 * Implementation of the {@link Updater} interface
 */ // tslint:disable-next-line:deprecation
var UpdaterImpl = /** @class */ (function () {
    /**
     * Create a new UpdaterImpl instance
     *
     * @param cid       the conversation ID
     * @param dispatch  the dispatcher for dispatching update source requests
     */
    function UpdaterImpl(cid, dispatch) {
        /**
         * A flag indicating whether the updater is closed
         */
        this.isClosed = false;
        this.cid = cid;
        this.dispatch = dispatch;
    }
    /**
     * Internal update that checks validity of the arguments and whether the
     * updater is closed before calling the dispatcher.
     *
     * @param path         the topic to update
     * @param value        the value to update the topic with
     * @param getDataType  a callback that will return a value depending on the
     *                     content
     * @return             the {@link Result} that completes when the update succeeded
     */
    UpdaterImpl.prototype.internalUpdate = function (topic, value, getDataType) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.isClosed) {
                reject(new Error('Updater is closed'));
            }
            else if (!topic) {
                reject(new Error('Topic can not be null or empty'));
            }
            else if (value === undefined || value === null) {
                reject(new Error('Update cannot be null'));
            }
            else {
                _this.dispatch(resolve, reject, _this.cid, topic, value, getDataType);
            }
        });
    };
    /**
     * @inheritdoc
     */
    UpdaterImpl.prototype.update = function (topic, value) {
        return this.internalUpdate(topic, value, function (content) {
            return datatypes_1.DataTypes.get(content);
        });
    };
    /**
     * @inheritdoc
     */
    UpdaterImpl.prototype.updateValue = function (topic, value, dataType) {
        return this.internalUpdate(topic, value, function () {
            return dataType;
        });
    };
    return UpdaterImpl;
}());
exports.UpdaterImpl = UpdaterImpl;
/**
 * Implementation of a {@link ResponseHandler} for handling topic updates
 */
var UpdateResponseHandler = /** @class */ (function () {
    /**
     * Create a new UpdateResponseHandler instance
     *
     * @param internal    the internal session
     * @param valueCache  the value cache
     * @param topic       the topic path
     * @param handler     the topic update handler that will handle the topic updates
     */ // tslint:disable-next-line:deprecation
    function UpdateResponseHandler(internal, valueCache, topic, handler) {
        /**
         * The state of the update source handler
         */
        this.state = update_source_state_1.UpdateSourceState.INIT;
        this.internal = internal;
        this.valueCache = valueCache;
        this.topic = topic;
        this.handler = handler;
        this.UPDATE_SOURCE_DEREGISTRATION = internal.getServiceLocator().obtain(Services.UPDATE_SOURCE_DEREGISTRATION);
        this.UPDATE_SOURCE_DELTA = internal.getServiceLocator().obtain(Services.UPDATE_SOURCE_DELTA);
        this.UPDATE_SOURCE_SET = internal.getServiceLocator().obtain(Services.UPDATE_SOURCE_SET);
    }
    /**
     * A dispatcher function for dispatching update source requests
     *
     * When bound to `this` this function is passed to the {@link UpdaterImpl}
     *
     * @param resolve       a callback to resolve the request
     * @param reject        a callback to signal an error
     * @param cid          the conversation ID
     * @param topic        the topic to update
     * @param value        the topic value
     * @param getDataType  a callback that will return a value depending on the
     *                     content
     */
    UpdateResponseHandler.prototype.dispatch = function (resolve, reject, cid, path, content, getDataType) {
        var callback = function (err, result) {
            if (err) {
                reject(err);
            }
            else if (result && result.error) {
                reject(new Error("Topic update error for topic " + path + " : " + result.error));
            }
            else {
                resolve();
            }
        };
        if (this.internal.checkConnected(reject)) {
            var datatype = getDataType(content);
            if (!datatype) {
                reject(topics_1.UpdateFailReasonEnum.INCOMPATIBLE_UPDATE);
                return;
            }
            var value = datatype.from(content);
            var prev = this.valueCache.get(path);
            if (prev) {
                var deltaType = datatype.deltaType('binary');
                var delta = deltaType.diff(prev, value);
                if (delta === deltaType.noChange()) {
                    callback(null);
                    return;
                }
                this.UPDATE_SOURCE_DELTA.send({
                    id: 0,
                    cid: cid,
                    path: path,
                    bytes: dataToBytes(delta)
                }, callback);
            }
            else {
                this.UPDATE_SOURCE_SET.send({
                    cid: cid,
                    path: path,
                    bytes: dataToBytes(value)
                }, callback);
            }
            this.valueCache.put(path, value);
        }
    };
    /**
     * @inheritdoc
     */
    UpdateResponseHandler.prototype.onOpen = function (cid) {
        var _this = this;
        this.close = function () {
            return new library_1.Promise(function (resolve, reject) {
                _this.UPDATE_SOURCE_DEREGISTRATION.send({ cid: cid }, function (err) {
                    if (err) {
                        _this.internal.getConversationSet().discard(cid, err);
                        reject(err);
                    }
                    else {
                        _this.internal.getConversationSet().respond(cid, {
                            old: _this.state,
                            current: update_source_state_1.UpdateSourceState.CLOSED
                        });
                        resolve();
                    }
                });
            });
        };
    };
    /**
     * @inheritdoc
     */
    UpdateResponseHandler.prototype.onResponse = function (cid, change) {
        if (change.old !== this.state) {
            this.internal.getConversationSet().discard(cid, new Error("Inconsistent server/client update source state. Current: " + this.state + ", expected: " + change.old));
            return false;
        }
        if (this.state === update_source_state_1.UpdateSourceState.INIT && change.current !== update_source_state_1.UpdateSourceState.CLOSED) {
            this.handler.onRegister(this.topic, this.close);
        }
        if (this.updater) {
            this.updater.isClosed = true;
        }
        this.state = change.current;
        switch (this.state) {
            case update_source_state_1.UpdateSourceState.ACTIVE:
                this.updater = new UpdaterImpl(cid, this.dispatch.bind(this));
                clearCache(this.valueCache, this.topic);
                this.handler.onActive(this.topic, this.updater);
                return false;
            case update_source_state_1.UpdateSourceState.STANDBY:
                this.handler.onStandBy(this.topic);
                return false;
            default:
                clearCache(this.valueCache, this.topic);
                this.handler.onClose(this.topic);
                return true;
        }
    };
    /**
     * @inheritdoc
     */
    UpdateResponseHandler.prototype.onDiscard = function (cid, reason) {
        this.state = update_source_state_1.UpdateSourceState.CLOSED;
        if (this.updater) {
            this.updater.isClosed = true;
        }
        clearCache(this.valueCache, this.topic);
        if (reason instanceof close_reason_1.CloseReasonImpl) {
            this.handler.onClose(this.topic);
        }
        else {
            this.handler.onClose(this.topic, reason);
        }
    };
    return UpdateResponseHandler;
}());
exports.UpdateResponseHandler = UpdateResponseHandler;
