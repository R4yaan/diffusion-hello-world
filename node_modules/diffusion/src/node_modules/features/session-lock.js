"use strict";
/**
 * @module Session.locks
 */
Object.defineProperty(exports, "__esModule", { value: true });
var internal_session_1 = require("client/internal-session");
var library_1 = require("core-js/library");
var Services = require("services/services");
var logger = require("util/logger");
var response_success_1 = require("util/response-success");
var session_lock_options_1 = require("../../features/session-lock-options");
var log = logger.create('diffusion.locks.SessionLocks');
/**
 * Implementation of the {@link SessionLock} interface
 */
var SessionLockImpl = /** @class */ (function () {
    /**
     * Create a new SessionLockImpl instance
     *
     * @param acquisition        the session lock acquisition
     * @param ownedSetter        the setter that will be initialised to allow
     *                           access to the `owned` property
     * @param unlockSessionLock  a callback that will unlock the session lock
     */
    function SessionLockImpl(acquisition, ownedSetter, unlockSessionLock) {
        var _this = this;
        /**
         * Flag indicating if the session lock is owned
         */
        this.owned = true;
        this.acquisition = acquisition;
        this.unlockSessionLock = unlockSessionLock;
        ownedSetter.setOwned = function (newOwned) {
            _this.owned = newOwned;
        };
    }
    /**
     * Convert the SessionLockImpl to a string
     *
     * @return  the string representation of the session lock
     */
    SessionLockImpl.prototype.toString = function () {
        return "SessionLock [name=" + this.acquisition.lockName + ", sequence=" + this.acquisition.sequence + ", "
            + ("scope=" + this.acquisition.scope + ", owned=" + this.owned + "]");
    };
    /**
     * @inheritdoc
     */
    SessionLockImpl.prototype.getName = function () {
        return this.acquisition.lockName;
    };
    /**
     * @inheritdoc
     */
    SessionLockImpl.prototype.getSequence = function () {
        return this.acquisition.sequence;
    };
    /**
     * @inheritdoc
     */
    SessionLockImpl.prototype.isOwned = function () {
        return this.owned;
    };
    /**
     * @inheritdoc
     */
    SessionLockImpl.prototype.getScope = function () {
        return this.acquisition.scope;
    };
    /**
     * @inheritdoc
     */
    SessionLockImpl.prototype.unlock = function () {
        if (this.owned) {
            this.owned = false;
            return this.unlockSessionLock(this.acquisition);
        }
        else {
            return library_1.Promise.resolve(false);
        }
    };
    return SessionLockImpl;
}());
exports.SessionLockImpl = SessionLockImpl;
/**
 * The internal session lock feature
 */
var InternalSessionLocks = /** @class */ (function () {
    /**
     * Create a new InternalSessionLocks implementation
     *
     * @param internal     the internal session
     * @param internalFsm  the finite state machine of the internal session
     */
    function InternalSessionLocks(internal, internalFsm) {
        var _this = this;
        /**
         * The map of locks indexed by their name
         */
        this.locks = {};
        /**
         * The next request id
         */
        this.nextRequestId = 0;
        this.serviceLocator = internal.getServiceLocator();
        // at the moment we do not implement cancellation of session locks
        // in the JavaScript api
        this.ACQUIRE_SESSION_LOCK = this.serviceLocator.obtain(Services.ACQUIRE_SESSION_LOCK);
        this.RELEASE_SESSION_LOCK = this.serviceLocator.obtain(Services.RELEASE_SESSION_LOCK);
        internalFsm.on('change', function (previous, current) {
            var failoverDetectionCid = null;
            var releaseLock = function (v) {
                v.ownedSetter.setOwned(false);
                v.onRemoveLock();
            };
            if (current === internal_session_1.InternalSessionState.DISCONNECTED) {
                // this client has detected connection loss
                library_1.Object.values(_this.locks)
                    .filter(function (v) { return (v.lock.getScope() === session_lock_options_1.SessionLockScope.UNLOCK_ON_CONNECTION_LOSS); })
                    .forEach(releaseLock);
                // there could be pending duplicate acquisitions
                // that will arrive after reconnection. We leave
                // lock in locks so we can filter these when they
                // arrive.
                // abuse a conversation set to detect failover and release the locks.
                // relies on the RECONNECTED_WITH_MESSAGE_LOSS handling to discard all current conversations.
                failoverDetectionCid = internal.getConversationSet().newConversation({
                    onOpen: function () {
                        // no-op
                    },
                    onResponse: function () {
                        // called on successful connection. Close this conversation.
                        return true;
                    },
                    onDiscard: function () {
                        // called on failover. We've lost all of the locks.
                        library_1.Object.values(_this.locks).forEach(releaseLock);
                        _this.locks = {};
                    }
                });
            }
            else if (current === internal_session_1.InternalSessionState.CONNECTED) {
                // tslint:disable-next-line:strict-type-predicates
                if (failoverDetectionCid !== null) {
                    internal.getConversationSet().respondIfPresent(failoverDetectionCid, null);
                    failoverDetectionCid = null;
                }
            }
            else if (current === internal_session_1.InternalSessionState.CLOSED) {
                library_1.Object.values(_this.locks).forEach(releaseLock);
                _this.locks = {};
            }
        });
    }
    /**
     * Handle a lock acquisition
     *
     * @param  lockName     the acquired lock name
     * @param  acquisition  the acquisition data sent by the server
     * @return              the new session lock
     */
    InternalSessionLocks.prototype.handleAcquisistion = function (lockName, acquisition, handler) {
        var oldLock = this.locks[lockName];
        var sessionLock;
        // tslint:disable-next-line:strict-type-predicates
        if (oldLock !== undefined) {
            if (!oldLock.lock.getSequence().equals(acquisition.sequence)) {
                // access the session locks owned member through
                oldLock.ownedSetter.setOwned(false);
                sessionLock = this.createLock(lockName, acquisition, handler);
            }
            else {
                sessionLock = oldLock.lock;
            }
        }
        else {
            sessionLock = this.createLock(lockName, acquisition, handler);
        }
        return sessionLock;
    };
    InternalSessionLocks.prototype.createLock = function (lockName, acquisition, handler) {
        var sessionLockOwnedSetter = {
            setOwned: function () {
                throw Error('Session lock ownedSetter must be implemented');
            }
        };
        var sessionLock = new SessionLockImpl(acquisition, sessionLockOwnedSetter, this.unlock.bind(this));
        var lockInfo = handler
            ? {
                lock: sessionLock,
                ownedSetter: {
                    setOwned: function (newOwned) {
                        sessionLockOwnedSetter.setOwned(newOwned);
                        handler.onOwned(newOwned);
                    }
                },
                onRemoveLock: function () {
                    handler.onRemoveLock();
                }
            }
            : {
                lock: sessionLock,
                ownedSetter: sessionLockOwnedSetter,
                onRemoveLock: function () { }
            };
        this.locks[lockName] = lockInfo;
        return sessionLock;
    };
    /**
     * Unlock a session lock identified by the acquisition details
     *
     * @param acquisition the lock acquisition details
     */
    InternalSessionLocks.prototype.unlock = function (acquisition) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            _this.RELEASE_SESSION_LOCK.send(acquisition, function (err, response) {
                if (err) {
                    log.debug('Release session lock failed');
                    reject(err);
                }
                else {
                    // tslint:disable-next-line:strict-type-predicates
                    if (_this.locks[acquisition.lockName] !== undefined
                        && _this.locks[acquisition.lockName].lock.getSequence().toString(10)
                            === acquisition.sequence.toString(10)) {
                        delete _this.locks[acquisition.lockName];
                    }
                    resolve(response);
                }
            });
        });
    };
    /**
     * Attempt to acquire a lock
     *
     * If a lock with the name is already owned by the session, the existing
     * lock will be returned. Otherwise a request will be sent to the server
     *
     * @param lockName  the lock name
     * @param scope     the lock scope
     * @return          a {@link Result} that resolves with the acquired session lock
     */
    InternalSessionLocks.prototype.lock = function (lockName, scope, handler) {
        var _this = this;
        if (scope === void 0) { scope = session_lock_options_1.SessionLockScope.UNLOCK_ON_SESSION_LOSS; }
        return new library_1.Promise(function (resolve, reject) {
            // tslint:disable-next-line:strict-type-predicates
            if (_this.locks[lockName] !== undefined && _this.locks[lockName].lock.isOwned()) {
                if (handler) {
                    reject(new Error('Cannot register the same lock in different shared sessions'));
                }
                else {
                    resolve(_this.locks[lockName].lock);
                }
            }
            else {
                var requestId = _this.nextRequestId++;
                _this.ACQUIRE_SESSION_LOCK.send({
                    lockName: lockName, requestId: requestId, scope: scope
                }, function (err, acquisition) {
                    if (!response_success_1.responseSuccess(err, acquisition)) {
                        log.debug('Acquire session lock failed');
                        reject(err);
                    }
                    else {
                        var newLock = _this.handleAcquisistion(lockName, acquisition, handler);
                        resolve(newLock);
                    }
                });
            }
        });
    };
    return InternalSessionLocks;
}());
exports.InternalSessionLocks = InternalSessionLocks;
