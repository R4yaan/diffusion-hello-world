"use strict";
/**
 * @module Security
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var CommandService = require("client/command-service");
var control_group_1 = require("control/control-group");
var registration_1 = require("control/registration");
var library_1 = require("core-js/library");
var security_script_builder_1 = require("features/security/security-script-builder");
var system_authentication_script_builder_1 = require("features/security/system-authentication-script-builder");
var security_command_script_1 = require("services/authentication/security-command-script");
var AuthenticationResponse = require("services/security/authentication-response");
var authenticator_response_1 = require("services/security/authenticator-response");
var Services = require("services/services");
var logger = require("util/logger");
var require_non_null_1 = require("util/require-non-null");
var error_reason_1 = require("../../errors/error-reason");
var security_1 = require("../../features/security");
var log = logger.create('Session.Security');
/**
 * Implementation of the {@link Security} feature
 */
var SecurityImpl = /** @class */ (function () {
    function SecurityImpl(internal) {
        /**
         * The global permission enum
         */ // tslint:disable-next-line:variable-name
        this.GlobalPermission = security_1.GlobalPermission;
        /**
         * The path permission enum
         */ // tslint:disable-next-line:variable-name
        this.PathPermission = security_1.PathPermission;
        /**
         * The topic permission enum
         * @deprecated since 6.5
         * Replaced by PathPermission
         */ // tslint:disable-next-line:variable-name
        this.TopicPermission = security_1.PathPermission;
        this.internal = internal;
        var serviceLocator = internal.getServiceLocator();
        this.CHANGE_PRINCIPAL = serviceLocator.obtain(Services.CHANGE_PRINCIPAL);
        this.GET_SECURITY_CONFIGURATION = serviceLocator.obtain(Services.GET_SECURITY_CONFIGURATION);
        this.GET_SYSTEM_AUTHENTICATION = serviceLocator.obtain(Services.GET_SYSTEM_AUTHENTICATION);
        this.UPDATE_SECURITY_CONFIGURATION = serviceLocator.obtain(Services.UPDATE_SECURITY_CONFIGURATION);
        this.UPDATE_SYSTEM_AUTHENTICATION = serviceLocator.obtain(Services.UPDATE_SYSTEM_AUTHENTICATION);
        this.AUTHENTICATOR_DEREGISTRATION = serviceLocator.obtain(Services.AUTHENTICATOR_DEREGISTRATION);
        this.LIST_GLOBAL_PERMISSIONS = serviceLocator.obtain(Services.LIST_GLOBAL_PERMISSIONS);
        this.LIST_PATH_PERMISSIONS = serviceLocator.obtain(Services.LIST_PATH_PERMISSIONS);
        internal.getServiceRegistry().add(Services.AUTHENTICATION, CommandService.create(function (internalSession, req, callback) {
            internalSession.getConversationSet().respondIfPresent(req.cid, { req: req, callback: callback });
        }));
        internal.getServiceRegistry().add(Services.AUTHENTICATOR, CommandService.create(function (internalSession, req, callback) {
            internalSession.getConversationSet().respondIfPresent(req.cid, { req: req, callback: callback });
        }));
    }
    /**
     * @inheritdoc
     */
    SecurityImpl.prototype.getPrincipal = function () {
        return this.internal.getPrincipal();
    };
    /**
     * @inheritdoc
     */
    SecurityImpl.prototype.changePrincipal = function (principal, credentials) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                log.debug('Changing principal', principal);
                _this.CHANGE_PRINCIPAL.send({
                    principal: principal,
                    credentials: credentials
                }, function (err, response) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        if (response) {
                            _this.internal.setPrincipal(principal);
                            resolve();
                        }
                        else {
                            reject(new Error('Unable to change principal due to authentication failure'));
                        }
                    }
                });
            }
        });
    };
    /**
     * @inheritdoc
     */
    SecurityImpl.prototype.getSecurityConfiguration = function () {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                log.debug('Getting security configuration');
                _this.GET_SECURITY_CONFIGURATION.send(null, function (err, response) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(response);
                    }
                });
            }
        });
    };
    /**
     * @inheritdoc
     */
    SecurityImpl.prototype.getSystemAuthenticationConfiguration = function () {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                log.debug('Getting system authentication');
                _this.GET_SYSTEM_AUTHENTICATION.send(null, function (err, response) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(response);
                    }
                });
            }
        });
    };
    /**
     * @inheritdoc
     */
    SecurityImpl.prototype.setAuthenticationHandler = function (name, details, 
    // tslint:disable-next-line:deprecation
    handler) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                log.debug("Setting Authentication Handler for \"" + name + "\"");
                var adapter = {
                    active: function (close) {
                        log.debug("Authentication Handler active for \"" + name + "\"");
                        handler.onActive(close);
                        resolve();
                    },
                    respond: function (msg) {
                        var req = msg.req;
                        var callback = msg.callback;
                        try {
                            handler.onAuthenticate(req.principal, req.credentials, req.details, {
                                allow: function (res) {
                                    callback.respond(res
                                        ? AuthenticationResponse.allow(res)
                                        : AuthenticationResponse.ALLOW);
                                },
                                abstain: function () {
                                    callback.respond(AuthenticationResponse.ABSTAIN);
                                },
                                deny: function () {
                                    callback.respond(AuthenticationResponse.DENY);
                                }
                            });
                        }
                        catch (err) {
                            handler.onError(err);
                            callback.fail(error_reason_1.ErrorReason.CALLBACK_EXCEPTION, err && err.message);
                            // rethrow so that the conversation can be discarded
                            throw err;
                        }
                        return false;
                    },
                    close: function (err) {
                        if (err) {
                            log.debug("'Authentication Handler closed with error for \"" + name + "\"'");
                            handler.onError(err);
                        }
                        else {
                            log.debug("'Authentication Handler closed for \"" + name + "\"'");
                            handler.onClose();
                        }
                    }
                };
                var params = {
                    definition: Services.AUTHENTICATION,
                    group: control_group_1.DEFAULT,
                    details: details,
                    name: name
                };
                return registration_1.registerHandler(_this.internal, params, adapter, Services.AUTHENTICATION_CONTROL_REGISTRATION, Services.AUTHENTICATION_CONTROL_DEREGISTRATION);
            }
        });
    };
    /**
     * @inheritdoc
     */
    SecurityImpl.prototype.setAuthenticator = function (handlerName, authenticator) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                try {
                    require_non_null_1.requireNonNull(handlerName, 'handlerName');
                    require_non_null_1.requireNonNull(authenticator, 'authenticator');
                }
                catch (e) {
                    reject(e);
                    return;
                }
                // tslint:disable:strict-type-predicates
                if (typeof authenticator.authenticate !== 'function'
                    || typeof authenticator.onError !== 'function'
                    || typeof authenticator.onClose !== 'function') {
                    // tslint:enable:strict-type-predicates
                    reject(new Error('authenticator does not implement the Authenticator interface'));
                }
                log.debug('Adding authenticator', handlerName);
                var params_1 = {
                    name: handlerName,
                    definition: Services.AUTHENTICATOR,
                    group: control_group_1.DEFAULT
                };
                var adapter = {
                    active: function (close, cid) {
                        log.debug('Authenticator active', handlerName);
                        var registration = {
                            close: function () {
                                return new library_1.Promise(function (resolveRegistration) {
                                    _this.AUTHENTICATOR_DEREGISTRATION.send(params_1, function (err, response) {
                                        if (err) {
                                            _this.internal.getConversationSet().discard(cid, err);
                                            log.debug('Error with authenticator deregistration: ', err);
                                        }
                                        else {
                                            _this.internal.getConversationSet().respondIfPresent(cid, response);
                                            authenticator.onClose();
                                        }
                                        resolveRegistration();
                                    });
                                });
                            }
                        };
                        resolve(registration);
                    },
                    respond: function (msg) {
                        var req = msg.req;
                        var callback = msg.callback;
                        try {
                            authenticator.authenticate(req.principal, req.credentials, req.sessionProperties, req.proposedProperties, {
                                allow: function (properties) {
                                    var e_1, _a;
                                    if (properties) {
                                        properties = library_1.Object.assign({}, properties);
                                        try {
                                            for (var _b = __values(library_1.Object.getOwnPropertyNames(req.sessionProperties)), _c = _b.next(); !_c.done; _c = _b.next()) {
                                                var key = _c.value;
                                                if (properties[key] === req.sessionProperties[key]) {
                                                    delete properties[key];
                                                }
                                            }
                                        }
                                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                                        finally {
                                            try {
                                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                            }
                                            finally { if (e_1) throw e_1.error; }
                                        }
                                    }
                                    callback.respond(new authenticator_response_1.AuthenticatorResponse(authenticator_response_1.TypeCode.ALLOW, properties));
                                },
                                abstain: function () {
                                    callback.respond(authenticator_response_1.ABSTAIN);
                                },
                                deny: function () {
                                    callback.respond(authenticator_response_1.DENY);
                                }
                            });
                        }
                        catch (err) {
                            authenticator.onError(err);
                            callback.fail(error_reason_1.ErrorReason.CALLBACK_EXCEPTION, err && err.message);
                            // rethrow so that the conversation can be discarded
                            throw err;
                        }
                        return false;
                    },
                    close: function (err) {
                        if (err) {
                            log.debug("'Authenticator closed with error for \"" + handlerName + "\"'");
                            authenticator.onError(err);
                        }
                        else {
                            log.debug("'Authentication Handler closed for \"" + handlerName + "\"'");
                            authenticator.onClose();
                        }
                    }
                };
                registration_1.registerHandler(_this.internal, params_1, adapter, Services.AUTHENTICATOR_REGISTRATION, Services.AUTHENTICATOR_DEREGISTRATION).then(undefined, function (err) {
                    reject(err);
                });
            }
        });
    };
    /**
     * Callback for processing the server response from a command script request.
     *
     * @param err       any errors from the server
     * @param response  the response from the server
     * @param resolve   a callback to resolve the request
     * @param reject    a callback to signal an error
     */
    SecurityImpl.prototype.updateStoreCallback = function (err, response, resolve, reject) {
        if (err) {
            reject(err);
        }
        else if (response.errors.length > 0) {
            reject(response.errors);
        }
        else {
            resolve();
        }
    };
    /**
     * Send a command script to the server and process the result
     *
     * @param  updater  the command service to send the script to
     * @param  script   the command script
     * @return          the {@link Result} that resolves when the operation
     *                  completes successfully
     */
    SecurityImpl.prototype.updateStore = function (updater, script) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (script === '') {
                resolve();
                // tslint:disable-next-line:strict-type-predicates
            }
            else if (!script || typeof script !== 'string') {
                reject(new Error("Invalid argument for script: " + script));
            }
            else if (_this.internal.checkConnected(reject)) {
                updater.send(new security_command_script_1.SecurityCommandScript(script), function (err, response) {
                    _this.updateStoreCallback(err, response, resolve, reject);
                });
            }
        });
    };
    /**
     * @inheritdoc
     */
    SecurityImpl.prototype.updateSecurityStore = function (script) {
        log.debug('Updating security store');
        return this.updateStore(this.UPDATE_SECURITY_CONFIGURATION, script);
    };
    /**
     * @inheritdoc
     */
    SecurityImpl.prototype.updateAuthenticationStore = function (script) {
        log.debug('Updating authentication store');
        return this.updateStore(this.UPDATE_SYSTEM_AUTHENTICATION, script);
    };
    /**
     * @inheritdoc
     */
    SecurityImpl.prototype.securityScriptBuilder = function () {
        return new security_script_builder_1.SecurityScriptBuilderImpl();
    };
    /**
     * @inheritdoc
     */
    SecurityImpl.prototype.authenticationScriptBuilder = function () {
        return new system_authentication_script_builder_1.SystemAuthenticationScriptBuilderImpl();
    };
    /**
     * @inheritdoc
     */
    SecurityImpl.prototype.getGlobalPermissions = function () {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                log.debug('Getting global permissions');
                _this.LIST_GLOBAL_PERMISSIONS.send(null, function (err, response) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(response.permissions);
                    }
                });
            }
        });
    };
    /**
     * @inheritdoc
     */
    SecurityImpl.prototype.getPathPermissions = function (path) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                log.debug('Getting path permissions');
                _this.LIST_PATH_PERMISSIONS.send(path, function (err, response) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(response.permissions);
                    }
                });
            }
        });
    };
    /**
     * @inheritdoc
     */
    // tslint:disable-next-line:deprecation
    SecurityImpl.prototype.getTopicPermissions = function (path) {
        var _this = this;
        // tslint:disable-next-line:deprecation
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                log.debug('Getting path permissions');
                _this.LIST_PATH_PERMISSIONS.send(path, function (err, response) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(response.permissions);
                    }
                });
            }
        });
    };
    return SecurityImpl;
}());
exports.SecurityImpl = SecurityImpl;
