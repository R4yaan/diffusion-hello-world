"use strict";
/**
 * @module Messages
 */
Object.defineProperty(exports, "__esModule", { value: true });
var command_service_1 = require("client/command-service");
var ControlGroup = require("control/control-group");
var registration_1 = require("control/registration");
var library_1 = require("core-js/library");
var datatypes_1 = require("data/datatypes");
var Services = require("services/services");
var session_id_1 = require("session/session-id");
var logger = require("util/logger");
var require_non_null_1 = require("util/require-non-null");
var response_success_1 = require("util/response-success");
var error_reason_1 = require("../../errors/error-reason");
var log = logger.create('Session.Messages');
/**
 * A request stream proxy
 */
var RequestStreamProxy = /** @class */ (function () {
    /**
     * Create a new RequestStreamProxy instance
     *
     * @param reqType  the request data type
     * @param resType  the response data type
     * @param stream   the request stream
     */
    function RequestStreamProxy(reqType, resType, stream) {
        this.reqType = reqType;
        this.resType = resType;
        this.stream = stream;
    }
    return RequestStreamProxy;
}());
/**
 * A responder to message requests
 */
var RequestResponder = /** @class */ (function () {
    /**
     * Create a new RequestResponder instance
     *
     * @param callback      the command service callback to send the response to
     * @param responseType  the response data type
     */
    function RequestResponder(callback, responseType) {
        this.callback = callback;
        this.responseType = responseType;
    }
    /**
     * Respond to the message with a response
     *
     * @param response  the response
     */
    RequestResponder.prototype.respond = function (response) {
        if (arguments.length === 0) {
            throw new Error('No argument provided to the responder');
        }
        if ((response === null || response === undefined) && !this.responseType) {
            throw new Error('No response type has been provided and the value provided is null. ' +
                'Unable to determine the response type.');
        }
        var dataType = this.responseType
            ? datatypes_1.DataTypes.getChecked(this.responseType)
            : datatypes_1.DataTypes.getByValue(response);
        if (dataType === undefined) {
            throw new Error('Unable to determine the response type.');
        }
        var responseData = dataType.writeValue(response);
        this.callback.respond({
            responseDataType: dataType.name(),
            data: responseData
        });
    };
    /**
     * Reject a message
     *
     * @param message  the message indicating the failure
     */
    RequestResponder.prototype.reject = function (message) {
        this.callback.fail(error_reason_1.ErrorReason.REJECTED_REQUEST, message);
    };
    return RequestResponder;
}());
/**
 * Returns a session ID if parseable, else false.
 *
 * @param str  the string containing the session ID
 * @return     the session ID or `false`
 */
function parseSessionId(str) {
    try {
        return session_id_1.SessionId.fromString(str);
    }
    catch (err) {
        return false;
    }
}
/**
 * Implementation of the {@link Messages} feature
 */
var MessagesImpl = /** @class */ (function () {
    /**
     * Create a new MessagesImpl instance
     *
     * @param internal  the internal session
     */
    function MessagesImpl(internal) {
        var _this = this;
        /**
         * The streams registered for the request-response service
         */
        this.requestStreams = {};
        this.internal = internal;
        var serviceLocator = internal.getServiceLocator();
        this.MESSAGING_SEND = serviceLocator.obtain(Services.MESSAGING_SEND);
        this.MESSAGING_FILTER_SEND = serviceLocator.obtain(Services.MESSAGING_FILTER_SEND);
        this.MESSAGING_RECEIVER_SERVER = serviceLocator.obtain(Services.MESSAGING_RECEIVER_SERVER);
        this.deregisterRequestHandler = serviceLocator.obtain(Services.MESSAGING_RECEIVER_CONTROL_DEREGISTRATION);
        var serviceRegistry = internal.getServiceRegistry();
        var formatNoStreamForPath = function (sessionID, path) {
            return "Session " + sessionID + " has no registered streams for message sent to path '" + path + "'";
        };
        serviceRegistry.add(Services.MESSAGING_SEND, command_service_1.create(function (session, request, callback) {
            var proxy = _this.requestStreams[request.path];
            // tslint:disable-next-line:strict-type-predicates
            if (proxy === undefined) {
                callback.fail(error_reason_1.ErrorReason.UNHANDLED_MESSAGE, formatNoStreamForPath(session.getSessionId(), request.path));
                return;
            }
            var responder = new RequestResponder(callback, proxy.resType);
            var requestDataType = datatypes_1.DataTypes.get(request.dataType);
            var requestType = proxy.reqType ? proxy.reqType : requestDataType.valueClass;
            if (requestDataType.canReadAs(requestType)) {
                var requestData = void 0;
                try {
                    requestData = requestDataType.readAs(requestType, request.request);
                }
                catch (e) {
                    log.error("Failed to convert " + requestDataType.name() + " datatype to " + requestType);
                    proxy.stream.onError(error_reason_1.ErrorReason.INVALID_DATA);
                    delete _this.requestStreams[request.path];
                    return;
                }
                try {
                    proxy.stream.onRequest(request.path, requestData, responder);
                }
                catch (e) {
                    log.error('Messaging request stream threw an error', e);
                    callback.fail(error_reason_1.ErrorReason.CALLBACK_EXCEPTION, e.stack);
                }
            }
            else {
                var message = "Messaging request for path " + request.path + " with " + requestDataType.name() +
                    ("datatype is incompatible for stream (" + requestType + ")");
                log.debug(message);
                callback.fail(error_reason_1.ErrorReason.INCOMPATIBLE_DATATYPE, message);
            }
        }));
        serviceRegistry.add(Services.FILTER_RESPONSE, command_service_1.create(function (session, request, callback) {
            callback.respond();
            session.getConversationSet().respondIfPresent(request.cid, request);
        }));
        serviceRegistry.add(Services.MESSAGING_RECEIVER_CLIENT, command_service_1.create(function (session, request, callback) {
            session.getConversationSet().respondIfPresent(request.cid, {
                request: request,
                callback: callback.respond,
                fail: callback.fail
            });
        }));
    }
    /**
     * @inheritdoc
     */
    MessagesImpl.prototype.addRequestHandler = function (path, handler, keys, requestType) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                try {
                    require_non_null_1.requireNonNull(path, 'Message path');
                    require_non_null_1.requireNonNull(handler, 'Request handler');
                }
                catch (e) {
                    reject(e);
                    return;
                }
                log.debug('Adding request handler', path);
                var params_1 = {
                    definition: Services.MESSAGING_RECEIVER_CLIENT,
                    group: ControlGroup.DEFAULT,
                    path: path,
                    keys: keys !== undefined ? keys : []
                };
                var adapter = {
                    active: function (close, cid) {
                        log.debug('Request handler active', path);
                        var registration = {
                            close: function () {
                                return new library_1.Promise(function (resolveRegistration) {
                                    _this.deregisterRequestHandler.send(params_1, function (err, response) {
                                        if (err) {
                                            _this.internal.getConversationSet().discard(cid, err);
                                            log.debug('Error with request handler deregistration: ', err);
                                        }
                                        else {
                                            handler.onClose();
                                            _this.internal.getConversationSet().respondIfPresent(cid, response);
                                        }
                                        resolveRegistration();
                                    });
                                });
                            }
                        };
                        resolve(registration);
                    },
                    respond: function (pair) {
                        log.debug('Request handler pair.request', path);
                        var context = {
                            sessionId: pair.request.sessionID,
                            path: pair.request.path,
                            properties: pair.request.properties
                        };
                        try {
                            var requestDatatype = requestType
                                ? requestType
                                : datatypes_1.DataTypes.getChecked(pair.request.dataType);
                            var request = requestDatatype.readValue(pair.request.content);
                            var responder = {
                                respond: function (response, respType) {
                                    var responseType = datatypes_1.DataTypes.getChecked(respType ? respType.name() : response);
                                    pair.callback({
                                        responseDataType: responseType.name(),
                                        data: responseType.writeValue(response)
                                    });
                                },
                                reject: function (message) {
                                    pair.fail(error_reason_1.ErrorReason.REJECTED_REQUEST, message);
                                }
                            };
                            handler.onRequest(request, context, responder);
                            return false;
                        }
                        catch (err) {
                            log.info('An exception has occurred whilst processing the request:', err);
                            handler.onError(err);
                            pair.fail(error_reason_1.ErrorReason.CALLBACK_EXCEPTION, err && err.message);
                            return false;
                        }
                    },
                    close: function () {
                        log.debug('Request handler closed', path);
                        handler.onClose();
                    }
                };
                registration_1.registerRequestHandler(_this.internal, params_1, adapter).then(undefined, function (err) {
                    reject(err);
                });
            }
        });
    };
    /**
     * Send a request to the controller
     *
     * This is called by {@link sendRequest} when no session was specified
     *
     * @param resolve       a callback to resolve the request
     * @param reject        a callback to signal an error
     * @param path          the path to send the request to
     * @param request       the request to send
     * @param requestType   an optional request {@link DataType DataType}
     * @param responseType  an optional response {@link DataType DataType}
     */
    MessagesImpl.prototype.sendRequestToController = function (resolve, reject, path, request, reqType, respType) {
        try {
            require_non_null_1.requireNonNull(path, 'Message path');
            require_non_null_1.requireNonNull(request, 'Request');
        }
        catch (e) {
            reject(e);
            return;
        }
        var requestType;
        try {
            requestType = reqType ? datatypes_1.DataTypes.getChecked(reqType) : datatypes_1.DataTypes.getByValue(request);
        }
        catch (e) {
            reject(e);
            return;
        }
        if (requestType === undefined) {
            throw new Error('Could not determine request type');
        }
        log.debug('Sending request to server', request);
        this.MESSAGING_SEND.send({
            path: path,
            dataType: requestType.name(),
            request: requestType.writeValue(request)
        }, function (err, response) {
            var responseType;
            if (!response_success_1.responseSuccess(err, response)) {
                log.debug('Request failed', path);
                reject(err);
            }
            else {
                log.debug('Request complete', path);
                try {
                    responseType = datatypes_1.DataTypes.getChecked(respType ? respType : response.responseDataType);
                }
                catch (e) {
                    reject(e);
                    return;
                }
                resolve(responseType.readValue(response.data));
            }
        });
    };
    /**
     * Send a request to a specific session
     *
     * This is called by {@link sendRequest} when a session was specified
     *
     * @param resolve       a callback to resolve the request
     * @param reject        a callback to signal an error
     * @param path          the path to send the request to
     * @param request       the request to send
     * @param sessionId     the target recipient's session ID
     * @param requestType   an optional request {@link DataType DataType}
     * @param responseType  an optional response {@link DataType DataType}
     */
    MessagesImpl.prototype.sendRequestToSession = function (resolve, reject, path, request, sessionId, reqType, respType) {
        try {
            require_non_null_1.requireNonNull(sessionId, 'Session ID');
            require_non_null_1.requireNonNull(path, 'Message path');
            require_non_null_1.requireNonNull(request, 'Request');
        }
        catch (e) {
            reject(e);
            return;
        }
        var requestType;
        try {
            requestType = reqType ? datatypes_1.DataTypes.getChecked(reqType) : datatypes_1.DataTypes.getByValue(request);
        }
        catch (e) {
            reject(e);
            return;
        }
        if (requestType === undefined) {
            throw new Error('Could not determine request type');
        }
        log.debug('Sending request to session', sessionId, request);
        this.MESSAGING_RECEIVER_SERVER.send({
            sessionId: sessionId,
            path: path,
            dataType: requestType.name(),
            request: requestType.writeValue(request)
        }, function (err, response) {
            var responseType;
            if (!response_success_1.responseSuccess(err, response)) {
                log.debug('Request failed', path);
                reject(err);
            }
            else {
                log.debug('Request complete', path);
                try {
                    responseType = datatypes_1.DataTypes.getChecked(respType ? respType : response.responseDataType);
                }
                catch (e) {
                    reject(e);
                    return;
                }
                resolve(responseType.readValue(response.data));
            }
        });
    };
    /**
     * @inheritdoc
     */
    MessagesImpl.prototype.sendRequest = function (path, request, sessionIdOrRequestType, requestTypeOrResponseType, responseType) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                if (sessionIdOrRequestType instanceof session_id_1.SessionId) {
                    _this.sendRequestToSession(resolve, reject, path, request, sessionIdOrRequestType, requestTypeOrResponseType, responseType);
                }
                else if (typeof sessionIdOrRequestType === 'string') {
                    var sessionId = parseSessionId(sessionIdOrRequestType);
                    if (sessionId) {
                        _this.sendRequestToSession(resolve, reject, path, request, sessionId, requestTypeOrResponseType, responseType);
                    }
                    else {
                        _this.sendRequestToController(resolve, reject, path, request, sessionIdOrRequestType, requestTypeOrResponseType);
                    }
                }
                else {
                    _this.sendRequestToController(resolve, reject, path, request, sessionIdOrRequestType, requestTypeOrResponseType);
                }
            }
        });
    };
    /**
     * @inheritdoc
     */
    MessagesImpl.prototype.sendRequestToFilter = function (filter, path, request, callback, reqType, respType) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                try {
                    require_non_null_1.requireNonNull(path, 'Message path');
                    require_non_null_1.requireNonNull(filter, 'Session filter');
                    require_non_null_1.requireNonNull(request, 'Request');
                    require_non_null_1.requireNonNull(callback, 'Response callback');
                }
                catch (e) {
                    reject(e);
                    return;
                }
                var requestType = void 0;
                try {
                    requestType = reqType ? datatypes_1.DataTypes.getChecked(reqType) : datatypes_1.DataTypes.getByValue(request);
                }
                catch (e) {
                    reject(e);
                    return;
                }
                if (requestType === undefined) {
                    throw new Error('Could not determine request type');
                }
                var count_1 = 0;
                var expected_1 = -1;
                var isDone_1 = function () {
                    return (count_1 >= expected_1 && expected_1 !== -1) || expected_1 === 0;
                };
                var cid_1 = _this.internal.getConversationSet().newConversation({
                    onOpen: function () {
                        // no-op
                    },
                    onResponse: function (conversationId, response) {
                        if (response === null) {
                            return true;
                        }
                        if (typeof response === 'number') {
                            expected_1 = response;
                            return isDone_1();
                        }
                        var sessionID = response.sessionID;
                        count_1++;
                        if (response.errorReason) {
                            callback.onResponseError(sessionID, response.errorReason);
                        }
                        else {
                            var responseDataType = datatypes_1.DataTypes.getByName(response.response.responseDataType);
                            var responseType = void 0;
                            try {
                                responseType = datatypes_1.DataTypes.getChecked(respType ? respType : response.response.responseDataType);
                            }
                            catch (e) {
                                reject(e);
                                return isDone_1();
                            }
                            if (responseDataType.canReadAs(responseType.valueClass)) {
                                var value = void 0;
                                try {
                                    value = responseDataType.readAs(responseType.valueClass, response.response.data);
                                }
                                catch (e) {
                                    callback.onResponseError(sessionID, e);
                                    return isDone_1();
                                }
                                try {
                                    callback.onResponse(sessionID, value);
                                }
                                catch (e) {
                                    log.error('Exception within messaging filter callback', e);
                                }
                            }
                            else {
                                callback.onResponseError(sessionID, new Error("The received response was a " + responseDataType + ",'\n                                        + ' which cannot be read as: " + responseType));
                            }
                        }
                        return isDone_1();
                    },
                    onDiscard: function (conversationId, err) {
                        callback.onError(err);
                    }
                });
                log.debug('Sending filter request to server', request);
                _this.MESSAGING_FILTER_SEND.send({
                    cid: cid_1,
                    path: path,
                    filter: filter,
                    dataType: requestType,
                    request: requestType.writeValue(request)
                }, function (err, response) {
                    if (!response_success_1.responseSuccess(err, response)) {
                        log.debug('Request failed', path);
                        _this.internal.getConversationSet().respondIfPresent(cid_1, null);
                        reject(err);
                    }
                    else if (response.isSuccess) {
                        log.debug('Request complete', path);
                        _this.internal.getConversationSet().respondIfPresent(cid_1, response.numberSent);
                        resolve(response.numberSent);
                    }
                    else {
                        log.debug('Request failed', path);
                        _this.internal.getConversationSet().respondIfPresent(cid_1, null);
                        reject(response.errors);
                    }
                });
            }
        });
    };
    /**
     * @inheritdoc
     */
    MessagesImpl.prototype.setRequestStream = function (path, stream, reqType, resType) {
        var proxy = new RequestStreamProxy(reqType ? datatypes_1.DataTypes.getValueClassChecked(reqType) : undefined, resType ? datatypes_1.DataTypes.getValueClassChecked(resType) : undefined, stream);
        var old = this.requestStreams[path];
        this.requestStreams[path] = proxy;
        if (old) {
            return old.stream;
        }
    };
    /**
     * @inheritdoc
     */
    MessagesImpl.prototype.removeRequestStream = function (path) {
        var proxy = this.requestStreams[path];
        delete this.requestStreams[path];
        if (proxy) {
            return proxy.stream;
        }
    };
    return MessagesImpl;
}());
exports.MessagesImpl = MessagesImpl;
