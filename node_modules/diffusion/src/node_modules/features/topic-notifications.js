"use strict";
/**
 * @module TopicNotifications
 */
Object.defineProperty(exports, "__esModule", { value: true });
var CommandService = require("client/command-service");
var registration_1 = require("control/registration");
var library_1 = require("core-js/library");
var Services = require("services/services");
var topic_selector_parser_1 = require("topics/topic-selector-parser");
var logger = require("util/logger");
var topic_notifications_1 = require("../../features/topic-notifications");
var log = logger.create('Session.Notifications');
/**
 * Implementation of the {@link TopicNotifications} feature
 */
var TopicNotificationsImpl = /** @class */ (function () {
    /**
     * Create a new TopicNotificationsImpl instance
     *
     * @param internal  the internal session
     */
    function TopicNotificationsImpl(internal) {
        /**
         * Exporting the {@link Session.notifications.TopicNotificationType}
         */
        this.TopicNotificationType = topic_notifications_1.TopicNotificationType;
        this.internal = internal;
        var serviceLocator = internal.getServiceLocator();
        this.conversationSet = internal.getConversationSet();
        this.TOPIC_NOTIFICATION_SELECTION = serviceLocator.obtain(Services.TOPIC_NOTIFICATION_SELECTION);
        this.TOPIC_NOTIFICATION_DESELECTION = serviceLocator.obtain(Services.TOPIC_NOTIFICATION_DESELECTION);
        this.TOPIC_NOTIFICATION_DEREGISTRATION = serviceLocator.obtain(Services.TOPIC_NOTIFICATION_DEREGISTRATION);
        var serviceRegistry = internal.getServiceRegistry();
        var eventService = CommandService.create(function (internalSession, request, callback) {
            callback.respond();
            internalSession.getConversationSet().respond(request.cid, request);
        });
        serviceRegistry.add(Services.TOPIC_NOTIFICATION_EVENTS, eventService);
        serviceRegistry.add(Services.TOPIC_DESCENDANT_EVENTS, eventService);
    }
    /**
     * @inheritdoc
     */
    TopicNotificationsImpl.prototype.addListener = function (listener) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (!listener) {
                reject(new Error('Topic Notification Listener is null or undefined'));
                return;
            }
            if (_this.internal.checkConnected(reject)) {
                log.debug('Adding Topic Notification Listener');
                var adapter = {
                    active: function (close, cid) {
                        log.debug('Topic Notification Listener active');
                        var topicNotificationRegistration = {
                            select: function (topicSelector) {
                                var args = [];
                                for (var _i = 1; _i < arguments.length; _i++) {
                                    args[_i - 1] = arguments[_i];
                                }
                                return new library_1.Promise(function (selectResolve, selectReject) {
                                    if (!topicSelector) {
                                        selectReject(new Error('No topic selector provided'));
                                        return;
                                    }
                                    try {
                                        var selector = (args.length > 0)
                                            ? topic_selector_parser_1.parseSelector([topicSelector].concat(args))
                                            : topic_selector_parser_1.parseSelector(topicSelector);
                                        _this.TOPIC_NOTIFICATION_SELECTION.send({ cid: cid, selector: selector }, function (err) {
                                            if (err) {
                                                _this.conversationSet.discard(cid, err);
                                                selectReject(err);
                                            }
                                            else {
                                                selectResolve();
                                            }
                                        });
                                    }
                                    catch (err) {
                                        selectReject(err);
                                    }
                                });
                            },
                            deselect: function (topicSelector) {
                                var args = [];
                                for (var _i = 1; _i < arguments.length; _i++) {
                                    args[_i - 1] = arguments[_i];
                                }
                                return new library_1.Promise(function (deselectResolve, deselectReject) {
                                    if (!topicSelector) {
                                        deselectReject(new Error('No topic selector provided'));
                                        return;
                                    }
                                    try {
                                        var selector = (args.length > 0)
                                            ? topic_selector_parser_1.parseSelector([topicSelector].concat(args))
                                            : topic_selector_parser_1.parseSelector(topicSelector);
                                        _this.TOPIC_NOTIFICATION_DESELECTION.send({ cid: cid, selector: selector }, function (err) {
                                            if (err) {
                                                _this.conversationSet.discard(cid, err);
                                                deselectReject(err);
                                            }
                                            else {
                                                deselectResolve();
                                            }
                                        });
                                    }
                                    catch (err) {
                                        deselectReject(err);
                                    }
                                });
                            },
                            close: function () {
                                _this.TOPIC_NOTIFICATION_DEREGISTRATION.send({ cid: cid }, function (err, response) {
                                    if (err) {
                                        _this.conversationSet.discard(cid, err);
                                        log.debug('Error with topic notification deregistration: ', err);
                                    }
                                    else {
                                        listener.onClose();
                                        _this.conversationSet.respondIfPresent(cid, response);
                                    }
                                });
                            }
                        };
                        resolve(topicNotificationRegistration);
                    },
                    respond: function (message) {
                        if (message.isDescendantEvent) {
                            listener.onDescendantNotification(message.path, message.type);
                        }
                        else {
                            listener.onTopicNotification(message.path, message.specification, message.type);
                        }
                        return false;
                    },
                    close: function (err) {
                        log.debug('Topic Notification Listener closed');
                        if (err) {
                            listener.onError(err);
                        }
                        else {
                            listener.onClose();
                        }
                    }
                };
                var conversationId = _this.conversationSet.newConversation(registration_1.responseHandler(_this.internal, adapter, function (cid, callback) {
                    _this.TOPIC_NOTIFICATION_DEREGISTRATION.send({ cid: cid }, callback);
                }));
                registration_1.registrationCallback(_this.conversationSet, conversationId, function () { }, function () { })(undefined);
            }
        });
    };
    return TopicNotificationsImpl;
}());
exports.TopicNotificationsImpl = TopicNotificationsImpl;
