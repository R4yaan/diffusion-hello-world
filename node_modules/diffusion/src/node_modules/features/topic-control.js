"use strict";
/**
 * @module TopicControl
 */
Object.defineProperty(exports, "__esModule", { value: true });
var CommandService = require("client/command-service");
var control_group_1 = require("control/control-group");
var registration_1 = require("control/registration");
var library_1 = require("core-js/library");
var universal_updater_1 = require("features/topic-control/universal-updater");
var update_source_state_1 = require("features/topic-control/update-source-state");
var value_cache_1 = require("features/topic-control/value-cache");
var update_response_handler_1 = require("features/update-response-handler");
var Services = require("services/services");
var topic_add_response_1 = require("services/topic-add/topic-add-response");
var topic_will_parameters_1 = require("services/wills/topic-will-parameters");
var will_registration_result_1 = require("services/wills/will-registration-result");
var topic_selector_parser_1 = require("topics/topic-selector-parser");
var logger = require("util/logger");
var response_success_1 = require("util/response-success");
var error_reason_1 = require("../../errors/error-reason");
var topic_specification_1 = require("../../topics/topic-specification");
var topic_type_1 = require("../../topics/topic-type");
var topics_1 = require("../../topics/topics");
var log = logger.create('Session.Topics');
// see ErrorReasonException.java
var errorReasonIdToAddFailReason = {
    103: topics_1.TopicAddFailReasonEnum.PERMISSIONS_FAILURE,
    110: topics_1.TopicAddFailReasonEnum.CLUSTER_REPARTITION,
    9004: topics_1.TopicAddFailReasonEnum.EXISTS_MISMATCH,
    9005: topics_1.TopicAddFailReasonEnum.INVALID_NAME,
    9006: topics_1.TopicAddFailReasonEnum.INVALID_DETAILS,
    9007: topics_1.TopicAddFailReasonEnum.EXCEEDED_LICENSE_LIMIT,
    9008: topics_1.TopicAddFailReasonEnum.INCOMPATIBLE_PARENT,
    9009: topics_1.TopicAddFailReasonEnum.INCOMPATIBLE_MASTER,
    9010: topics_1.TopicAddFailReasonEnum.EXISTS_INCOMPATIBLE,
    9011: topics_1.TopicAddFailReasonEnum.UNEXPECTED_ERROR
};
/**
 * Implementation of the {@link TopicControl} feature
 */
var TopicControlImpl = /** @class */ (function () {
    /**
     * Create a new TopicControlImpl instance
     *
     * @param internal  the internal session
     */
    function TopicControlImpl(internal) {
        this.internal = internal;
        var serviceLocator = internal.getServiceLocator();
        this.TOPIC_ADD_SERVICE = serviceLocator.obtain(Services.TOPIC_ADD);
        this.TOPIC_REMOVAL = serviceLocator.obtain(Services.TOPIC_REMOVAL);
        this.TOPIC_WILL_REGISTRATION = serviceLocator.obtain(Services.TOPIC_SCOPED_WILL_REGISTRATION);
        this.TOPIC_WILL_DEREGISTRATION = serviceLocator.obtain(Services.TOPIC_SCOPED_WILL_DEREGISTRATION);
        this.UPDATE_SOURCE_REGISTRATION = serviceLocator.obtain(Services.UPDATE_SOURCE_REGISTRATION);
        this.valueCache = new value_cache_1.ValueCache();
        this.universalUpdater = new universal_updater_1.UniversalUpdater(internal);
        // Updater state service
        var serviceRegistry = internal.getServiceRegistry();
        serviceRegistry.add(Services.UPDATE_SOURCE_STATE, CommandService.create(function (internalSession, request, callback) {
            callback.respond();
            internalSession.getConversationSet().respondIfPresent(request.cid, {
                old: request.old,
                current: request.current
            });
        }));
        serviceRegistry.add(Services.MISSING_TOPIC, CommandService.create(function (internalSession, request, callback) {
            internalSession.getConversationSet().respondIfPresent(request.cid, {
                request: request,
                callback: callback
            });
        }));
    }
    /**
     * Check if the supplied topic type is supported
     *
     * @param type  the topic type or specification
     * @return      `true` if the type is one of the supported topic types
     */
    TopicControlImpl.prototype.isSupportedTopicType = function (type) {
        return Object.keys(topic_type_1.TopicTypeEnum).some(function (t) { return (topic_type_1.TopicTypeEnum[t] === type); });
    };
    /**
     * @inheritdoc
     */
    TopicControlImpl.prototype.add = function (path, specification) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (!path) {
                reject({
                    id: 0,
                    reason: 'Path cannot be empty or null'
                });
                return;
            }
            if (_this.internal.checkConnected(reject)) {
                log.debug('Adding topic', path);
                var topicSpecification = _this.isSupportedTopicType(specification)
                    ? new topic_specification_1.TopicSpecification(specification)
                    : specification;
                if (!(topicSpecification instanceof topic_specification_1.TopicSpecification)) {
                    throw new Error('Invalid topic specification or type');
                }
                // use Protocol 13 - TopicAdd service
                _this.TOPIC_ADD_SERVICE.send({
                    path: path, specification: topicSpecification
                }, function (err, response) {
                    if (err) {
                        reject(errorReasonIdToAddFailReason[err.id]);
                    }
                    else {
                        _this.valueCache.put(path, undefined);
                        resolve({
                            topic: path,
                            added: response.status === topic_add_response_1.TopicAddResponseStatus.OK
                        });
                    }
                });
            }
        });
    };
    /**
     * @inheritdoc
     */
    TopicControlImpl.prototype.remove = function (expression) {
        var _this = this;
        var selectors = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            selectors[_i - 1] = arguments[_i];
        }
        var args = arguments;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                log.debug('Removing topics', expression);
                try {
                    _this.TOPIC_REMOVAL.send({
                        selector: (args.length > 1)
                            ? topic_selector_parser_1.parseSelector(Array.prototype.slice.call(args))
                            : topic_selector_parser_1.parseSelector(expression)
                    }, function (err) {
                        if (err) {
                            log.debug('Topic removal failed', expression);
                            reject(err);
                        }
                        else {
                            log.debug('Topic removal complete', expression);
                            resolve();
                        }
                    });
                }
                catch (err) {
                    log.debug('Error parsing selector', expression);
                    reject(err);
                }
            }
        });
    };
    /**
     * @inheritdoc
     */
    TopicControlImpl.prototype.removeWithSession = function (path) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                log.debug('Registering removeWithSession', path);
                var params_1 = new topic_will_parameters_1.TopicWillParameters(path, topic_will_parameters_1.Will.REMOVE_TOPICS);
                _this.TOPIC_WILL_REGISTRATION.send(params_1, function (err, response) {
                    if (!response_success_1.responseSuccess(err, response)) {
                        log.debug('removeWithSession registration failed', path);
                        reject(err);
                    }
                    else if (response.result === will_registration_result_1.WillRegistrationResultEnum.SUCCESS) {
                        log.debug('removeWithSession registration complete', path);
                        var registered_1 = true;
                        var deregister = function () {
                            return new library_1.Promise(function (dResolve, dReject) {
                                if (registered_1 && _this.internal.checkConnected(dReject)) {
                                    log.debug('Deregistering removeWithSession', path);
                                    _this.TOPIC_WILL_DEREGISTRATION.send(params_1, function (error) {
                                        if (error) {
                                            dReject(error);
                                        }
                                        else {
                                            registered_1 = false;
                                            dResolve({
                                                topic: path
                                            });
                                        }
                                    });
                                }
                            });
                        };
                        resolve({
                            deregister: deregister
                        });
                    }
                    else {
                        log.debug('removeWithSession registration failed', path);
                        reject(new Error('REGISTRATION_CONFLICT'));
                    }
                });
            }
        });
    };
    /**
     * @inheritdoc
     */
    TopicControlImpl.prototype.update = function (path, content) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (_this.internal.checkConnected(reject)) {
                log.debug('Updating topic', path);
                var callback = function (error, response) {
                    if (error) {
                        log.debug('Update failed', path);
                        reject(error);
                    }
                    else if (response.isError) {
                        log.debug('Update failed', path);
                        reject(response.reason);
                    }
                    else {
                        log.debug('Update complete', path);
                        resolve(path);
                    }
                };
                _this.universalUpdater.update(path, content, callback);
            }
        });
    };
    /**
     * @inheritdoc
     */
    TopicControlImpl.prototype.updateValue = function (path, content, datatype) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (!datatype) {
                reject(new Error('Data type is required'));
                return;
            }
            if (_this.internal.checkConnected(reject)) {
                log.debug('Updating topic', path);
                var callback = function (error, response) {
                    if (error) {
                        log.debug('Update failed', path);
                        reject(error);
                    }
                    else if (response.isError) {
                        log.debug('Update failed', path);
                        reject(response.reason);
                    }
                    else {
                        log.debug('Update complete', path);
                        resolve(path);
                    }
                };
                _this.universalUpdater.updateValue(path, content, datatype, callback);
            }
        });
    };
    /**
     * @inheritdoc
     */ // tslint:disable-next-line:deprecation
    TopicControlImpl.prototype.registerUpdateSource = function (path, handler) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            var conversations = _this.internal.getConversationSet();
            var cid = conversations.newConversation(new update_response_handler_1.UpdateResponseHandler(_this.internal, _this.valueCache, path, handler));
            if (_this.internal.checkConnected(reject)) {
                _this.UPDATE_SOURCE_REGISTRATION.send({
                    cid: cid,
                    path: path
                }, function (err, response) {
                    if (!response_success_1.responseSuccess(err, response) || response.state === update_source_state_1.UpdateSourceState.CLOSED) {
                        conversations.discard(cid, err);
                        reject(err);
                    }
                    else {
                        conversations.respond(cid, { old: update_source_state_1.UpdateSourceState.INIT, current: response.state });
                        resolve();
                    }
                });
            }
        });
    };
    /**
     * @inheritdoc
     */
    TopicControlImpl.prototype.addMissingTopicHandler = function (path, handler) {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            if (!handler) {
                reject(new Error('Missing Topic handler is null or undefined'));
                return;
            }
            if (_this.internal.checkConnected(reject)) {
                var adapter = {
                    active: function (close) {
                        log.debug('Missing Topic Handler registered for ' + path);
                        handler.onRegister(path, close);
                        resolve();
                    },
                    respond: function (response) {
                        var callback = response.callback;
                        log.debug('Missing Topic Handler notification for ' +
                            response.request.sessionID +
                            ' using ' +
                            response.request.selector);
                        try {
                            handler.onMissingTopic({
                                path: response.request.selector.prefix,
                                selector: response.request.selector,
                                sessionID: response.request.sessionID,
                                proceed: function () {
                                    callback.respond(true);
                                },
                                cancel: function () {
                                    callback.respond(false);
                                }
                            });
                        }
                        catch (err) {
                            handler.onError(path, err);
                            callback.fail(error_reason_1.ErrorReason.CALLBACK_EXCEPTION, err && err.message);
                            // rethrow so that the conversation can be discarded
                            throw err;
                        }
                        return false;
                    },
                    close: function (err) {
                        log.debug('Missing Topic Handler closed for ' + path);
                        if (err) {
                            handler.onError(path, err);
                        }
                        else {
                            handler.onClose(path);
                        }
                    }
                };
                var params = {
                    definition: Services.MISSING_TOPIC,
                    group: control_group_1.DEFAULT,
                    path: path
                };
                resolve(registration_1.registerTopicHandler(_this.internal, params, adapter));
            }
        });
    };
    return TopicControlImpl;
}());
exports.TopicControlImpl = TopicControlImpl;
