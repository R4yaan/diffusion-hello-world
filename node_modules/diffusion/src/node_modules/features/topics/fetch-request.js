"use strict";
/**
 * @module FetchRequest
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var library_1 = require("core-js/library");
var any_datatype_1 = require("data/any-datatype");
var datatypes_1 = require("data/datatypes");
var fetch_result_1 = require("features/topics/fetch-result");
var fetch_query_1 = require("services/fetch-query/fetch-query");
var Services = require("services/services");
var topic_selector_parser_1 = require("topics/topic-selector-parser");
var logger = require("util/logger");
var math_1 = require("util/math");
var response_success_1 = require("util/response-success");
var fetch_request_1 = require("../../../topics/fetch-request");
var topic_type_1 = require("../../../topics/topic-type");
var log = logger.create('Fetch Request');
/**
 * A fetch range limit
 */
var Limit = /** @class */ (function () {
    /**
     * Create a new Limit instance
     *
     * @param  path          the limiting path
     * @param  includesPath  a flag indicating whether the limiting path is
     *                       included in the range
     */
    function Limit(path, includesPath) {
        this.path = path;
        this.includesPath = includesPath;
    }
    return Limit;
}());
exports.Limit = Limit;
/**
 * A fetch request topic range
 */
var FetchRange = /** @class */ (function () {
    /**
     * Create a new FetchRange instance
     *
     * @param  from  the lower limit of the range
     * @param  to    the upper limit of the range
     */
    function FetchRange(from, to) {
        this.from = from;
        this.to = to;
    }
    /**
     * Check if the range is unbounded
     *
     * @return  `true` if no limits are set
     */
    FetchRange.prototype.isUnbounded = function () {
        return this.from === undefined && this.to === undefined;
    };
    return FetchRange;
}());
exports.FetchRange = FetchRange;
/**
 * Indicates whether a specified topic type can be read as a specified
 * data type.
 *
 * @param {TopicType} topicType the topic type
 * @param {diffusion.datatypes.DataType} dataType the data type
 *
 * @returns {Boolean} true if the topic type can be read as the data type
 * @function diffusion.topics.FetchRequestImpl#canReadAs
 */
function canReadAs(topicType, dataType) {
    if (topicType === topic_type_1.TopicTypeEnum.TIME_SERIES) {
        return fetch_result_1.TIME_SERIES_DATA_TYPE.canReadAs(dataType);
    }
    else {
        var topicDataType = datatypes_1.DataTypes.getByValue(topicType);
        // tslint:disable-next-line:strict-type-predicates
        return topicDataType !== null && dataType.valueClass !== undefined
            && topicDataType.canReadAs(dataType.valueClass);
    }
}
function requireNonNegative(n, parameter) {
    if (!Number.isInteger(n) || n < 0) {
        throw new Error("Invalid argument " + parameter + ": " + n);
    }
    return n;
}
/**
 * Implementation of the {@link FetchRequest} builder interface
 */
var FetchRequestImpl = /** @class */ (function (_super) {
    __extends(FetchRequestImpl, _super);
    /**
     * Create a new FetchRequestImpl instance
     *
     * @param internal  the internal session
     * @param opts      the internal options specifying what to fetch
     */
    function FetchRequestImpl(internal, opts) {
        var _this = _super.call(this) || this;
        var defaultOptions = {
            range: new FetchRange(),
            topicTypes: fetch_request_1.FetchRequest.getAllTypes(),
            dataType: undefined,
            withProperties: false,
            limit: math_1.MAX_INT32,
            maximumResultSize: internal.getOptions().maxMessageSize,
            deepBranchDepth: math_1.MAX_INT32,
            deepBranchLimit: math_1.MAX_INT32,
            withUnpublishedDelayedTopics: false
        };
        _this.internal = internal;
        _this.options = library_1.Object.assign(defaultOptions, opts);
        return _this;
    }
    /**
     * Deep copy the options into a new {@link FetchRequestOptions} instance
     *
     * @return  the new options instance
     */
    FetchRequestImpl.prototype.copyOptions = function () {
        return {
            range: new FetchRange(this.options.range.from, this.options.range.to),
            topicTypes: new library_1.Set(this.options.topicTypes),
            dataType: this.options.dataType,
            withProperties: this.options.withProperties,
            limit: this.options.limit,
            maximumResultSize: this.options.maximumResultSize,
            deepBranchDepth: this.options.deepBranchDepth,
            deepBranchLimit: this.options.deepBranchLimit,
            withUnpublishedDelayedTopics: this.options.withUnpublishedDelayedTopics
        };
    };
    /**
     * @inheritdoc
     */
    FetchRequestImpl.prototype.from = function (topicPath) {
        var limit = new Limit(topicPath, true);
        return new FetchRequestImpl(this.internal, library_1.Object.assign(this.copyOptions(), { range: new FetchRange(limit, this.options.range.to) }));
    };
    /**
     * @inheritdoc
     */
    FetchRequestImpl.prototype.after = function (topicPath) {
        var limit = new Limit(topicPath, false);
        return new FetchRequestImpl(this.internal, library_1.Object.assign(this.copyOptions(), { range: new FetchRange(limit, this.options.range.to) }));
    };
    /**
     * @inheritdoc
     */
    FetchRequestImpl.prototype.to = function (topicPath) {
        var limit = new Limit(topicPath, true);
        return new FetchRequestImpl(this.internal, library_1.Object.assign(this.copyOptions(), { range: new FetchRange(this.options.range.from, limit) }));
    };
    /**
     * @inheritdoc
     */
    FetchRequestImpl.prototype.before = function (topicPath) {
        var limit = new Limit(topicPath, false);
        return new FetchRequestImpl(this.internal, library_1.Object.assign(this.copyOptions(), { range: new FetchRange(this.options.range.from, limit) }));
    };
    /**
     * @inheritdoc
     */
    FetchRequestImpl.prototype.topicTypes = function (topicTypes) {
        var _this = this;
        if (topicTypes.length === 0) {
            throw new Error('No types specified');
        }
        var allTypes = fetch_request_1.FetchRequest.getAllTypes();
        // ensure that those supplied are valid and if there is a value
        // class that the types can be read as the value class.
        topicTypes.forEach(function (topicType) {
            if (!allTypes.has(topicType)) {
                // tslint:disable-next-line:deprecation
                throw new Error("Invalid topic type " + topicType.id);
            }
            if (_this.options.dataType !== undefined
                && !canReadAs(topicType, _this.options.dataType)) {
                // tslint:disable-next-line:deprecation
                throw new Error("Topic type " + topicType.id + " cannot be read as " + _this.options.dataType);
            }
        });
        return new FetchRequestImpl(this.internal, library_1.Object.assign(this.copyOptions(), { topicTypes: new library_1.Set(topicTypes) }));
    };
    /**
     * @inheritdoc
     */
    FetchRequestImpl.prototype.withValues = function (dataType) {
        var selectedTopicTypes;
        // tslint:disable-next-line:strict-type-predicates
        if (dataType !== undefined && !(dataType instanceof any_datatype_1.AnyDataTypeImpl)) {
            selectedTopicTypes = new library_1.Set(this.options.topicTypes);
            this.options.topicTypes.forEach(function (topicType) {
                if (!canReadAs(topicType, dataType)) {
                    selectedTopicTypes.delete(topicType);
                }
            });
            if (selectedTopicTypes.size === 0) {
                throw new Error("No selected topic types can be read as " + dataType);
            }
        }
        else {
            selectedTopicTypes = this.options.topicTypes;
        }
        return new FetchRequestImpl(this.internal, library_1.Object.assign(this.copyOptions(), { topicTypes: selectedTopicTypes, dataType: dataType }));
    };
    /**
     * @inheritdoc
     */
    FetchRequestImpl.prototype.withProperties = function () {
        return new FetchRequestImpl(this.internal, library_1.Object.assign(this.copyOptions(), { withProperties: true }));
    };
    /**
     * @inheritdoc
     */
    FetchRequestImpl.prototype.first = function (count) {
        return new FetchRequestImpl(this.internal, library_1.Object.assign(this.copyOptions(), { limit: requireNonNegative(count, 'count') }));
    };
    /**
     * @inheritdoc
     */
    FetchRequestImpl.prototype.last = function (count) {
        return new FetchRequestImpl(this.internal, library_1.Object.assign(this.copyOptions(), { limit: 0 - requireNonNegative(count, 'count') }));
    };
    /**
     * @inheritdoc
     */
    FetchRequestImpl.prototype.maximumResultSize = function (maximumSize) {
        return new FetchRequestImpl(this.internal, library_1.Object.assign(this.copyOptions(), {
            maximumResultSize: Math.min(requireNonNegative(maximumSize, 'maximumSize'), this.internal.getOptions().maxMessageSize)
        }));
    };
    FetchRequestImpl.prototype.limitDeepBranches = function (deepBranchDepth, deepBranchLimit) {
        return new FetchRequestImpl(this.internal, library_1.Object.assign(this.copyOptions(), {
            deepBranchDepth: requireNonNegative(deepBranchDepth, 'deepBranchDepth'),
            deepBranchLimit: requireNonNegative(deepBranchLimit, 'deepBranchLimit'),
        }));
    };
    FetchRequestImpl.prototype.withUnpublishedDelayedTopics = function () {
        return new FetchRequestImpl(this.internal, library_1.Object.assign(this.copyOptions(), { withUnpublishedDelayedTopics: true }));
    };
    /**
     * @inheritdoc
     */
    FetchRequestImpl.prototype.fetch = function (topics) {
        var _this = this;
        var serviceLocator = this.internal.getServiceLocator();
        var FETCH_QUERY = serviceLocator.obtain(Services.FETCH_QUERY);
        var selector = (arguments.length > 1)
            ? topic_selector_parser_1.parseSelector(Array.prototype.slice.call(arguments))
            : topic_selector_parser_1.parseSelector(topics);
        var query = new fetch_query_1.FetchQuery(selector, this.options.range, this.options.topicTypes, this.options.dataType !== undefined, this.options.withProperties, this.options.limit, this.options.maximumResultSize, this.options.deepBranchDepth, this.options.deepBranchLimit, this.options.withUnpublishedDelayedTopics);
        return new library_1.Promise(function (resolve, reject) {
            FETCH_QUERY.send(query, function (err, fetchQueryResult) {
                if (!response_success_1.responseSuccess(err, fetchQueryResult)) {
                    log.debug('Fetch query failed');
                    reject(err);
                }
                else {
                    var fetchResult = new fetch_result_1.FetchResultImpl(_this.options.dataType, fetchQueryResult);
                    resolve(fetchResult);
                }
            });
        });
    };
    return FetchRequestImpl;
}(fetch_request_1.FetchRequest));
exports.FetchRequestImpl = FetchRequestImpl;
