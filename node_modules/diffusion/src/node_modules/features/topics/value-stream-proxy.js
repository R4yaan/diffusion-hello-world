"use strict";
/**
 * @module ValueStream
 */
Object.defineProperty(exports, "__esModule", { value: true });
var datatypes_1 = require("data/datatypes");
var emitter_1 = require("events/emitter");
var value_stream_1 = require("features/topics/value-stream");
var value_stream_adapter_1 = require("features/topics/value-stream-adapter");
var time_series_event_datatype_1 = require("timeseries/time-series-event-datatype");
var selector_set_1 = require("topics/selector-set");
var topic_type_1 = require("../../../topics/topic-type");
/**
 * Internal proxy for Subscriptions with an underlying datatype.
 */
var ValueStreamProxy = /** @class */ (function () {
    /**
     * Create a new ValueStreamProxy interface
     *
     * @param registry  the stream registry
     * @param selector  the topic selector
     * @param datatype  the data type of the value stream
     * @param fallback  whether this is a fallback stream or not
     */
    function ValueStreamProxy(registry, selector, datatype, fallback, subscriptionFactory, adapterFactory) {
        var _this = this;
        /**
         * Flag indicating that the stream has not yet been added to the stream registry
         */
        this.pending = true;
        var factory = emitter_1.Emitter.create();
        this.subscription = subscriptionFactory(factory, selector);
        this.emitter = factory.emitter(this.subscription);
        this.subscription.on('close', function () {
            registry.remove(_this);
        });
        this.adapterFactory = adapterFactory;
        this.datatype = datatype;
        this.registry = registry;
        var onEvent = this.subscription.on.bind(this.subscription);
        // monkey-patch so that we will only register this stream if it is subsequently used
        this.subscription.on = function (event, fn) {
            var stream = onEvent(event, fn);
            if (_this.pending) {
                if (fallback) {
                    registry.addFallback(_this, datatype);
                }
                else {
                    registry.add(selector, _this, datatype);
                }
                _this.pending = false;
            }
            return stream;
        };
    }
    /**
     * @inheritdoc
     */
    ValueStreamProxy.prototype.selects = function (specification) {
        if (specification) {
            if (specification.type === topic_type_1.TopicTypeEnum.TIME_SERIES) {
                var eventType = datatypes_1.DataTypes.get(specification.properties.TIME_SERIES_EVENT_VALUE_TYPE);
                var dataType = this.datatype instanceof time_series_event_datatype_1.TimeSeriesEventDataType
                    ? datatypes_1.DataTypes.get(this.datatype.valueTypeName)
                    : this.datatype;
                return !!eventType && eventType.canReadAs(dataType.valueClass);
            }
            else {
                return datatypes_1.DataTypes.getByValue(specification.type)
                    .canReadAs(this.datatype.valueClass);
            }
        }
        return false;
    };
    /**
     * @inheritdoc
     */
    ValueStreamProxy.prototype.adapter = function (specification) {
        if ((specification.type === topic_type_1.TopicTypeEnum.TIME_SERIES)
            || (specification.type === topic_type_1.TopicTypeEnum[this.datatype.name().toUpperCase()])) {
            return this;
        }
        else {
            return this.adapterFactory(this, this.datatype, specification.type);
        }
    };
    /**
     * @inheritdoc
     */
    ValueStreamProxy.prototype.onOpen = function () {
        this.emitter.emit('open', this.subscription);
    };
    /**
     * @inheritdoc
     */
    ValueStreamProxy.prototype.onDelta = function (path, specification, oldContent, content, delta, oldValue, newValue) {
        this.emitter.emit('value', path, specification, newValue, oldValue);
    };
    /**
     * @inheritdoc
     */
    ValueStreamProxy.prototype.onValue = function (path, specification, oldContent, content, oldValue, newValue) {
        this.emitter.emit('value', path, specification, newValue, oldValue);
    };
    /**
     * @inheritdoc
     */
    ValueStreamProxy.prototype.onSubscription = function (path, specification) {
        this.emitter.emit('subscribe', path, specification);
    };
    /**
     * @inheritdoc
     */
    ValueStreamProxy.prototype.onUnsubscription = function (path, specification, reason) {
        this.emitter.emit('unsubscribe', path, specification, reason);
    };
    /**
     * @inheritdoc
     */
    ValueStreamProxy.prototype.onSubscriptionError = function (error) {
        this.emitter.error(error);
        this.registry.remove(this);
    };
    return ValueStreamProxy;
}());
exports.ValueStreamProxy = ValueStreamProxy;
var FALLBACK_SELECTOR = new selector_set_1.SelectorSet([]);
/**
 * Factory function for creating a new ValueStreamProxy interface
 *
 * @param registry  the stream registry
 * @param selector  the topic selector
 * @param datatype  the data type of the value stream
 * @param fallback  whether this is a fallback stream or not
 */
function create(registry, datatype, fallback, selector) {
    if (selector === void 0) { selector = FALLBACK_SELECTOR; }
    var proxy = new ValueStreamProxy(registry, selector, datatype, fallback, function (factory, topicSelector) {
        return new value_stream_1.ValueStreamImpl(factory, topicSelector);
    }, function (stream, streamDatatype, topictype) {
        return new value_stream_adapter_1.ValueStreamAdapter(stream, streamDatatype, topictype);
    });
    return proxy.subscription;
}
exports.create = create;
