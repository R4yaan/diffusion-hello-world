"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var enumerize_1 = require("util/enumerize");
var require_non_null_1 = require("util/require-non-null");
/**
 * Require that a number is defined and is not negative
 *
 * @param  i     the number to check
 * @param  what  a description of the number to check
 * @return       the number
 * @throws       an error if the number is not defined or negative
 */
function requireNonNegative(i, what) {
    if (i === undefined || i === null || i < 0) {
        throw new Error(what + " is negative: " + i);
    }
    return i;
}
/**
 * A point type
 */
var Type = /** @class */ (function () {
    /**
     * Create a Point Type
     *
     * @param   id              the type id
     * @param   anchorOperator  a string describing where the point is anchored
     * @param   spanOperator    a string describing the span of the point
     * @param   unitsSuffix     the unit suffix
     */
    function Type(id, anchorOperator, spanOperator, unitsSuffix) {
        this.id = id;
        this.anchorOperator = anchorOperator;
        this.spanOperator = spanOperator;
        this.unitsSuffix = unitsSuffix;
    }
    return Type;
}());
exports.Type = Type;
/**
 * Enum like object of point types
 */ // tslint:disable-next-line:variable-name
exports.Types = {
    ABSOLUTE_START: new Type(0, 'fromStart', 'toStart', ''),
    ABSOLUTE_SEQUENCE: new Type(1, 'from', 'to', ''),
    ABSOLUTE_TIME: new Type(2, 'from', 'to', ' ms'),
    OFFSET_SEQUENCE: new Type(3, 'fromLast', 'untilLast', ''),
    OFFSET_TIME: new Type(4, 'fromLast', 'untilLast', ' ms'),
    NEXT_COUNT: new Type(5, null, 'next', ''),
    NEXT_TIME: new Type(6, null, 'next', ' ms'),
    PREVIOUS_COUNT: new Type(7, null, 'previous', ''),
    PREVIOUS_TIME: new Type(8, null, 'previous', ' ms')
};
enumerize_1.enumerize(exports.Types);
/**
 * A point in a time series, either specified by the event number or a time
 */
var Point = /** @class */ (function () {
    /**
     * Create a Point instance
     *
     * @param  value  the point value
     * @param  type   the point type
     */
    function Point(value, type) {
        this.value = value;
        this.type = type;
    }
    /**
     * Create a new point that is anchored at an absolute position.
     *
     * @param sequence  the date or number at which the point is anchored
     * @return          a new point
     */
    Point.at = function (sequence) {
        if (sequence instanceof Date) {
            return new Point(require_non_null_1.requireNonNull(sequence, 'Date').getTime(), exports.Types.ABSOLUTE_TIME);
        }
        return new Point(requireNonNegative(sequence, 'Sequence'), exports.Types.ABSOLUTE_SEQUENCE);
    };
    /**
     * Get a start point
     *
     * @return  a unique instance of the start point
     */
    Point.atStart = function () {
        /* tslint:disable-next-line:no-use-before-declare */
        return START_POINT;
    };
    /**
     * Create a point with a sequence offset. The point refers to a position
     * `count` events before the end of the sequence
     *
     * @oaram count  the sequence offset
     * @return       a new point
     */
    Point.offset = function (count) {
        return new Point(requireNonNegative(count, 'Count'), exports.Types.OFFSET_SEQUENCE);
    };
    /**
     * Create a point with a time offset. The point refers to a position
     * `timespan` milliseconds before the end of the sequence.
     *
     * @oaram count  the time offset in milliseconds
     * @return       a new point
     */
    Point.offsetMillis = function (timespan) {
        return new Point(requireNonNegative(timespan, 'Timespan'), exports.Types.OFFSET_TIME);
    };
    /**
     * Create a point following a previous point by a number of events
     *
     * @oaram count  the number of events
     * @return       a new point
     */
    Point.next = function (count) {
        return new Point(requireNonNegative(count, 'Count'), exports.Types.NEXT_COUNT);
    };
    /**
     * Create a point following a previous point by a time span
     *
     * @oaram timespan  the number of milliseconds
     * @return          a new point
     */
    Point.nextMillis = function (timespan) {
        return new Point(requireNonNegative(timespan, 'Timespan'), exports.Types.NEXT_TIME);
    };
    /**
     * Create a point preceding another point by a number of events
     *
     * @oaram count  the number of events
     * @return       a new point
     */
    Point.previous = function (count) {
        return new Point(requireNonNegative(count, 'Count'), exports.Types.PREVIOUS_COUNT);
    };
    /**
     * Create a point preceding another point by a time span
     *
     * @oaram timespan  the number of milliseconds
     * @return          a new point
     */
    Point.previousMillis = function (timespan) {
        return new Point(requireNonNegative(timespan, 'Timespan'), exports.Types.PREVIOUS_TIME);
    };
    /**
     * Check if the Point is equal to another object
     *
     * @param  other the other object
     * @return       `true` if the other object is a Point and is equal
     */
    Point.prototype.equals = function (other) {
        if (other && other instanceof Point) {
            return this.value === other.value &&
                this.type === other.type;
        }
        return false;
    };
    return Point;
}());
exports.Point = Point;
/**
 * A unique start point
 */
var START_POINT = new Point(0, exports.Types.ABSOLUTE_START);
