"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var point_1 = require("features/time-series/point");
/**
 * A range of events in a time series specified by an anchor point and a span
 */
var Range = /** @class */ (function () {
    /**
     * Create a new Range instance
     *
     * @param  anchor  the anchor point
     * @param  span    the span
     */
    function Range(anchor, span) {
        this.anchor = anchor;
        this.span = span;
    }
    /**
     * Check if the Range is equal to another object
     *
     * @param  other the other object
     * @return       `true` if the other object is a Range and is equal
     */
    Range.prototype.equals = function (other) {
        if (other && other instanceof Range) {
            return this.anchor.equals(other.anchor) &&
                this.span.equals(other.span);
        }
        return false;
    };
    /**
     * Create a new Range with the same span but a new anchor at a given time
     * or event count
     *
     * @param  start  the starting anchor
     * @return        a new Range object
     */
    Range.prototype.from = function (start) {
        return new Range(point_1.Point.at(start), this.span);
    };
    /**
     * Create a new Range with the same span but anchored at the beginning of
     * the time series
     *
     * @return  a new Range object
     */
    Range.prototype.fromStart = function () {
        return new Range(point_1.Point.atStart(), this.span);
    };
    /**
     * Create a new Range with the same span but a new anchor at a given
     * event count before the end of the time series.
     *
     * @param  count  the offset from the end of the time series
     * @return        a new Range object
     */
    Range.prototype.fromLast = function (count) {
        return new Range(point_1.Point.offset(count), this.span);
    };
    /**
     * Create a new Range with the same span but a new anchor at a given
     * timespan before the end of the time series.
     *
     * @param  timespan  the timespan from the end of the time series
     * @return           a new Range object
     */
    Range.prototype.fromLastMillis = function (timespan) {
        return new Range(point_1.Point.offsetMillis(timespan), this.span);
    };
    /**
     * Create a new Range with the same anchor but a new span at a given time
     * or event count
     *
     * @param  sequence  the end anchor
     * @return           a new Range object
     */
    Range.prototype.to = function (sequence) {
        return new Range(this.anchor, point_1.Point.at(sequence));
    };
    /**
     * Create a new Range with the same anchor but ending at the beginning of
     * the time series
     *
     * @return  a new Range object
     */
    Range.prototype.toStart = function () {
        return new Range(this.anchor, point_1.Point.atStart());
    };
    /**
     * Create a new Range with the same anchor but a new end point at a given
     * event count before the end of the time series.
     *
     * @param  count  the offset from the end of the time series
     * @return        a new Range object
     */
    Range.prototype.untilLast = function (count) {
        return new Range(this.anchor, point_1.Point.offset(count));
    };
    /**
     * Create a new Range with the same anchor but a new end point at a given
     * timespan before the end of the time series.
     *
     * @param  timespan  the timespan from the end of the time series
     * @return           a new Range object
     */
    Range.prototype.untilLastMillis = function (timespan) {
        return new Range(this.anchor, point_1.Point.offsetMillis(timespan));
    };
    /**
     * Create a new Range with the same anchor but a span containing a fixed
     * number of events.
     *
     * @param  count  the number of events in the span
     * @return        a new Range object
     */
    Range.prototype.next = function (count) {
        return new Range(this.anchor, point_1.Point.next(count));
    };
    /**
     * Create a new Range with the same anchor but a span covering a fixed
     * timespan.
     *
     * @param  timespan  the timespan covered by the range
     * @return           a new Range object
     */
    Range.prototype.nextMillis = function (timespan) {
        return new Range(this.anchor, point_1.Point.nextMillis(timespan));
    };
    /**
     * Create a new Range with the same anchor but a span containing a fixed
     * number of events before the anchor.
     *
     * @param  count  the number of events in the span
     * @return        a new Range object
     */
    Range.prototype.previous = function (count) {
        return new Range(this.anchor, point_1.Point.previous(count));
    };
    /**
     * Create a new Range with the same anchor but a span covering a fixed
     * timespan before the anchor.
     *
     * @param  timespan  the timespan covered by the range
     * @return           a new Range object
     */
    Range.prototype.previousMillis = function (timespan) {
        return new Range(this.anchor, point_1.Point.previousMillis(timespan));
    };
    return Range;
}());
exports.Range = Range;
/**
 * A unique range covering the complete time series
 */
exports.DEFAULT_RANGE = new Range(point_1.Point.atStart(), point_1.Point.offset(0));
