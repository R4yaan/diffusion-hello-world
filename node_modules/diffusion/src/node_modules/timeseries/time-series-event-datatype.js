"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var abstract_datatype_1 = require("data/abstract-datatype");
var buffer_slice_1 = require("data/buffer-slice");
var bytes_impl_1 = require("data/bytes-impl");
var buffer_input_stream_1 = require("io/buffer-input-stream");
var buffer_output_stream_1 = require("io/buffer-output-stream");
var Codec = require("io/codec");
var time_series_event_1 = require("services/timeseries/time-series-event");
var time_series_event_metadata_serialiser_1 = require("services/timeseries/time-series-event-metadata-serialiser");
/**
 * Event type constants
 */
var EventType;
(function (EventType) {
    EventType[EventType["ORIGINAL_EVENT"] = 0] = "ORIGINAL_EVENT";
    EventType[EventType["EDIT_EVENT"] = 1] = "EDIT_EVENT";
})(EventType || (EventType = {}));
/**
 * A converter function that converts an event to bytes data
 *
 * @param valueToBytes  a converter function that converts an underlying value to bytes data
 * @param event         the event to convert
 * @return              the bytes containing the event
 */
function eventToBytes(valueToBytes, event) {
    if (!event) {
        throw new Error('Cannot convert null event to Bytes');
    }
    return new bytes_impl_1.BytesImpl(writeValue(valueToBytes, event));
}
/**
 * A converter function that converts an event to buffer data
 *
 * @param valueToBytes  a converter function that converts an underlying value to bytes data
 * @param event         the event to convert
 * @return              the buffer containing the event
 */
function writeValue(valueToBytes, event) {
    var output = new buffer_output_stream_1.BufferOutputStream();
    if (event.isEditEvent) {
        Codec.writeByte(output, EventType.EDIT_EVENT);
        time_series_event_metadata_serialiser_1.EventMetadataImplSerialiser.write(output, event.originalEvent);
    }
    else {
        Codec.writeByte(output, EventType.ORIGINAL_EVENT);
    }
    time_series_event_metadata_serialiser_1.EventMetadataImplSerialiser.write(output, event);
    var serialised = valueToBytes(event.value);
    Codec.writeBytes(output, serialised.$buffer);
    return output.getBuffer();
}
/**
 * A converter function that converts bytes data to an event
 *
 * @param bytesToValue  a converter function that converts bytes data to an underlying value
 * @param bytes         the bytes containing the event in binary form
 * @return              the event that was extracted from the bytes
 */
function bytesToEvent(bytesToValue, bytes) {
    var input = new buffer_input_stream_1.BufferInputStream(bytes.$buffer);
    var eventType = Codec.readByte(input);
    switch (eventType) {
        case EventType.ORIGINAL_EVENT:
            return readOriginalEvent(bytesToValue, input);
        case EventType.EDIT_EVENT:
            return readEditEvent(bytesToValue, input);
        default:
            throw new Error('Unrecognised event type: ' + eventType);
    }
}
/**
 * Read an original event from an input stream
 *
 * @param bytesToValue a converter function that converts a byte data to a value
 * @param input        the input stream
 * @return             the event that was read from the stream
 */
function readOriginalEvent(bytesToValue, input) {
    var metadata = time_series_event_metadata_serialiser_1.EventMetadataImplSerialiser.read(input);
    var value = bytesToValue(Codec.readBytes(input));
    return time_series_event_1.EventImpl.create(metadata, metadata, value);
}
/**
 * Read an edit event from an input stream
 *
 * @param bytesToValue a converter function that converts a byte data to a value
 * @param input        the input stream
 * @return             the event that was read from the stream
 */
function readEditEvent(bytesToValue, input) {
    var originalEvent = time_series_event_metadata_serialiser_1.EventMetadataImplSerialiser.read(input);
    var metadata = time_series_event_metadata_serialiser_1.EventMetadataImplSerialiser.read(input);
    var value = bytesToValue(Codec.readBytes(input));
    return time_series_event_1.EventImpl.create(metadata, originalEvent, value);
}
/**
 * A data type for time series {@link Event} values
 *
 * @param <ValueType>   the value type of the data type
 * @param <SourceType>  the type(s) from which a value can be constructed
 */
var TimeSeriesEventDataType = /** @class */ (function (_super) {
    __extends(TimeSeriesEventDataType, _super);
    /**
     * Create a new TimeSeriesEventDataType instance
     *
     * @param name  the name of the data type
     * @param valueTypeName  the data type name of the event's value type
     * @param bytesToValue a converter function that converts a byte data to a value
     * @param valueToBytes a converter function that converts a value to bytes data
     */
    function TimeSeriesEventDataType(name, valueTypeName, bytesToValue, valueToBytes) {
        var _this = _super.call(this, name, time_series_event_1.EventImpl, bytes_impl_1.BytesImpl, function (e) {
            return eventToBytes(valueToBytes, e);
        }, function (b) {
            return bytesToEvent(bytesToValue, b);
        }, [], true) || this;
        _this.valueToBytes = valueToBytes;
        _this.valueTypeName = valueTypeName;
        return _this;
    }
    /**
     * Create a new time series event datatype from a delegate datatype.
     *
     * @param  delegate  the delegate data type
     * @param <ValueType>   the value type of the data type
     * @param <SourceType>  the type(s) from which a value can be constructed
     * @param <CBORType>    the binary type containing the CBOR data
     */
    TimeSeriesEventDataType.create = function (delegate) {
        return new TimeSeriesEventDataType("timeseriesevent-" + delegate.name(), delegate.name(), delegate.readValue.bind(delegate), delegate.toBytes.bind(delegate));
    };
    /**
     * @inheritdoc
     */
    TimeSeriesEventDataType.prototype.writeValue = function (event) {
        return writeValue(this.valueToBytes, event);
    };
    /**
     * @inheritdoc
     */
    TimeSeriesEventDataType.prototype.validate = function () {
        // no-op: validates on read
    };
    /**
     * @inheritdoc
     */
    TimeSeriesEventDataType.prototype.from = function (value) {
        return (value instanceof buffer_slice_1.BufferSlice)
            ? value
            : this.valueToBytes(value.value);
    };
    return TimeSeriesEventDataType;
}(abstract_datatype_1.AbstractDataType));
exports.TimeSeriesEventDataType = TimeSeriesEventDataType;
