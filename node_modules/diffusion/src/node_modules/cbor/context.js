"use strict";
/**
 * @module CBOR
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A CBOR token context type
 */
var TokenContextType;
(function (TokenContextType) {
    /**
     * the type given to the root context
     */
    TokenContextType[TokenContextType["root"] = 0] = "root";
    /**
     * the token context when reading string
     */
    TokenContextType[TokenContextType["string"] = 1] = "string";
    /**
     * the token context when reading an array
     */
    TokenContextType[TokenContextType["array"] = 2] = "array";
    /**
     * the token context when reading an object
     */
    TokenContextType[TokenContextType["object"] = 3] = "object";
})(TokenContextType = exports.TokenContextType || (exports.TokenContextType = {}));
/**
 * Maintain recursive parsing context on a stack.
 */
var Context = /** @class */ (function () {
    function Context() {
        /**
         * the root context
         */
        this.ROOT = { length: -1, type: TokenContextType.root, read: 0 };
        /**
         * the context stack
         */
        this.stack = [];
        /**
         * the current context
         */
        this.tail = this.ROOT;
    }
    /**
     * Get the context type
     *
     * @returns the type of the current token context
     */
    Context.prototype.type = function () {
        return this.tail.type;
    };
    /**
     * Get the number of read tokens
     *
     * @returns the number of tokens that have been read in the current token context
     */
    Context.prototype.read = function () {
        return this.tail.read;
    };
    /**
     * Get the number of tokens that are expected in this context
     *
     * @returns the length of the current token context
     */
    Context.prototype.expected = function () {
        return this.tail.length;
    };
    /**
     * Add a new context
     *
     * @param type of the token context
     * @param the number of tokens are expected the new token context
     */
    Context.prototype.push = function (type, length) {
        if (length === void 0) { length = -1; }
        this.tail = {
            length: length,
            type: type,
            read: 0
        };
        this.stack.push(this.tail);
    };
    /**
     * Pop the current context
     *
     * @returns the previous tail on the context stack
     */
    Context.prototype.pop = function () {
        var prev = this.stack.pop();
        if (this.stack.length) {
            this.tail = this.stack[this.stack.length - 1];
        }
        else {
            this.tail = this.ROOT;
        }
        return prev;
    };
    /**
     * Progress through the current context's expected value count
     */
    Context.prototype.next = function () {
        if (this.hasRemaining()) {
            this.tail.read++;
        }
        else {
            throw new Error('Exceeded expected collection limit');
        }
    };
    /**
     * Ends this current context.
     */
    Context.prototype.break = function () {
        if (this.acceptsBreakMarker()) {
            this.tail.length = 0;
            this.tail.read = 0;
        }
    };
    /**
     * Check if the current context has token remaining to be read
     *
     * @returns `true` if there are more tokens expected in this context
     */
    Context.prototype.hasRemaining = function () {
        return (this.tail.length === -1) || (this.tail.length > this.tail.read);
    };
    /**
     * Check if the current context can accept a break marker
     *
     * @returns whether the current context accepts break marker tokens
     */
    Context.prototype.acceptsBreakMarker = function () {
        return this.tail !== this.ROOT && this.tail.length === -1;
    };
    return Context;
}());
exports.Context = Context;
