"use strict";
/**
 * @module CBOR
 *
 * @brief This module contains functions and classes to encode and decode CBOR to and
 * from a `Buffer`.
 *
 * Follows [RFC 7049](https://tools.ietf.org/html/rfc7049#section-2.1) standard
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The data types that can be encoded in CBOR
 *
 * Follows [RFC 7049](https://tools.ietf.org/html/rfc7049#section-2.1) standard
 * for the major type.
 */
var types;
(function (types) {
    types[types["UINT"] = 0] = "UINT";
    types[types["INT"] = 1] = "INT";
    types[types["BYTES"] = 2] = "BYTES";
    types[types["STRING"] = 3] = "STRING";
    types[types["ARRAY"] = 4] = "ARRAY";
    types[types["MAP"] = 5] = "MAP";
    types[types["SEMANTIC"] = 6] = "SEMANTIC";
    types[types["SIMPLE"] = 7] = "SIMPLE";
    types[types["FLOAT"] = 7] = "FLOAT";
})(types = exports.types || (exports.types = {}));
/**
 * Additional information about a data type
 *
 * Follows [RFC 7049](https://tools.ietf.org/html/rfc7049#section-2.3) standard
 * for additional information on floating-point numbers and values with no content.
 */
var additional;
(function (additional) {
    additional[additional["FALSE"] = 20] = "FALSE";
    additional[additional["TRUE"] = 21] = "TRUE";
    additional[additional["NULL"] = 22] = "NULL";
    additional[additional["UNDEFINED"] = 23] = "UNDEFINED";
    additional[additional["SIMPLE"] = 24] = "SIMPLE";
    additional[additional["HALF_PRECISION"] = 25] = "HALF_PRECISION";
    additional[additional["SINGLE_PRECISION"] = 26] = "SINGLE_PRECISION";
    additional[additional["DOUBLE_PRECISION"] = 27] = "DOUBLE_PRECISION";
    additional[additional["BREAK"] = 31] = "BREAK";
})(additional = exports.additional || (exports.additional = {}));
/**
 * Token types
 */
var tokens;
(function (tokens) {
    tokens[tokens["ARRAY_START"] = 0] = "ARRAY_START";
    tokens[tokens["ARRAY_END"] = 1] = "ARRAY_END";
    tokens[tokens["MAP_START"] = 2] = "MAP_START";
    tokens[tokens["MAP_END"] = 3] = "MAP_END";
    tokens[tokens["STRING_START"] = 4] = "STRING_START";
    tokens[tokens["STRING_END"] = 5] = "STRING_END";
    tokens[tokens["VALUE"] = 6] = "VALUE";
})(tokens = exports.tokens || (exports.tokens = {}));
/**
 * Utility function to check for starting tokens of arrays, maps, or strings
 *
 * @param  token the token to check
 * @return       `true` if the token starts a structure
 */
function isStructStart(token) {
    switch (token) {
        case tokens.ARRAY_START:
        case tokens.MAP_START:
        case tokens.STRING_START:
            return true;
        default:
            return false;
    }
}
exports.isStructStart = isStructStart;
/**
 * Utility function to check for ending tokens of arrays, maps, or strings
 *
 * @param  token the token to check
 * @return       `true` if the token ends a structure
 */
function isStructEnd(token) {
    switch (token) {
        case tokens.ARRAY_END:
        case tokens.MAP_END:
        case tokens.STRING_END:
            return true;
        default:
            return false;
    }
}
exports.isStructEnd = isStructEnd;
