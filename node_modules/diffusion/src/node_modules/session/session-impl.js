"use strict";
/**
 * @module Session
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var library_1 = require("core-js/library");
var emitter_1 = require("events/emitter");
var client_control_1 = require("features/client-control");
var log_retrieval_1 = require("features/log-retrieval");
var messages_1 = require("features/messages");
var metrics_1 = require("features/metrics");
var ping_1 = require("features/ping");
var remote_servers_1 = require("features/remote-servers");
var replace_license_1 = require("features/replace-license");
var security_1 = require("features/security");
var time_series_impl_1 = require("features/time-series/time-series-impl");
var topic_control_1 = require("features/topic-control");
var topic_notifications_1 = require("features/topic-notifications");
var topic_update_1 = require("features/topic-update");
var topic_views_1 = require("features/topic-views");
var topics_1 = require("features/topics");
var options_impl_1 = require("session/options-impl");
var session_lock_options_1 = require("../../features/session-lock-options");
/**
 * Immplementation of the {@link Session} interface
 */
var SessionImpl = /** @class */ (function (_super) {
    __extends(SessionImpl, _super);
    /**
     * Create a new SessionImpl instance
     *
     * @param sessionID        the session ID
     * @param options          the session options
     * @param internalSession  the internal session
     */
    function SessionImpl(sessionId, options, internalSession) {
        var _this = this;
        var factory = emitter_1.Emitter.create();
        _this = _super.call(this, internalSession, factory) || this;
        var emitter = factory.emitter(_this);
        // re-emit internal session events
        internalSession.on({
            reconnect: function () {
                emitter.emit('reconnect');
            },
            disconnect: function (reason) {
                emitter.emit('disconnect', reason);
            },
            error: function (err) {
                emitter.emit('error', err);
            },
            close: function (reason) {
                emitter.emit('close', reason);
            }
        });
        _this.topics = new topic_control_1.TopicControlImpl(internalSession);
        _this.clients = new client_control_1.ClientControlImpl(internalSession);
        _this.messages = new messages_1.MessagesImpl(internalSession);
        _this.notifications = new topic_notifications_1.TopicNotificationsImpl(internalSession);
        _this.remoteServers = new remote_servers_1.RemoteServersImpl(internalSession);
        _this.security = new security_1.SecurityImpl(internalSession);
        _this.timeseries = new time_series_impl_1.TimeSeriesImpl(internalSession);
        _this.topicUpdate = new topic_update_1.TopicUpdateImpl(internalSession);
        _this.topicViews = new topic_views_1.TopicViewsImpl(internalSession);
        _this.logRetrieval = new log_retrieval_1.LogRetrieval(internalSession);
        _this.metrics = new metrics_1.Metrics(internalSession);
        _this.licenceUpdater = new replace_license_1.LicenceUpdater(internalSession);
        _this.sessionId = sessionId;
        _this.sessionID = sessionId.toString();
        _this.ping = new ping_1.PingImpl(internalSession);
        // remove credentials to prevent 3rd party access
        _this.options = options !== undefined
            ? options.with({
                credentials: undefined
            })
            : {};
        return _this;
    }
    /**
     * @inheritdoc
     */
    SessionImpl.prototype.close = function () {
        this.internal.close();
        return this;
    };
    /**
     * @inheritdoc
     */
    SessionImpl.prototype.closeSession = function () {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            _this.on('close', resolve);
            _this.close();
        });
    };
    /**
     * @inheritdoc
     */
    SessionImpl.prototype.isClosed = function () {
        var state = this.internal.getState();
        return state === 'closing' || state === 'closed';
    };
    /**
     * @inheritdoc
     */
    SessionImpl.prototype.isConnected = function () {
        return this.internal.isConnected();
    };
    SessionImpl.prototype.toString = function () {
        return "Session<" + this.sessionId + " " + this.internal.getState() + ">";
    };
    /**
     * @inheritdoc
     */
    SessionImpl.prototype.getPrincipal = function () {
        return this.options.principal || '';
    };
    /**
     * @inheritdoc
     */
    SessionImpl.prototype.lock = function (lockName, scope) {
        if (scope === void 0) { scope = session_lock_options_1.SessionLockScope.UNLOCK_ON_SESSION_LOSS; }
        return this.internal.lock(lockName, scope);
    };
    /**
     * @inheritdoc
     */
    SessionImpl.prototype.pingServer = function () {
        return this.ping.pingServer();
    };
    /**
     * Get the server's maximum message size.
     *
     * <p>Not exposed through the API.
     */
    SessionImpl.prototype.getServerMaximumMessageSize = function () {
        return this.internal.getServerMaximumMessageSize();
    };
    /**
     * Create a new session object
     *
     * @param internalSessionFactory  a factory function for creating new internal
     *                                sessions
     * @param options                 the user supplied options, may be undefined
     *                                when connecting to a shared sesssion
     * @returns                       a result that resolves with the new session
     */
    SessionImpl.create = function (internalSessionFactory, options) {
        // merge defaults if options argument is defined
        var optionsImpl;
        if (options !== undefined) {
            optionsImpl = (typeof options === 'string')
                ? new options_impl_1.OptionsImpl({ host: options })
                : new options_impl_1.OptionsImpl(options);
        }
        // connection promise
        return new library_1.Promise(function (resolve, reject) {
            var internalSession = internalSessionFactory(optionsImpl);
            function onConnect(sessionId, opts) {
                internalSession.off('connect', onConnect);
                internalSession.off('close', onError);
                internalSession.off('error', onError);
                resolve(new SessionImpl(sessionId, opts || optionsImpl, internalSession));
            }
            function onError(err) {
                internalSession.off('connect', onConnect);
                internalSession.off('close', onError);
                internalSession.off('error', onError);
                reject(err);
            }
            internalSession.on('connect', onConnect);
            internalSession.on('close', onError);
            internalSession.on('error', onError);
            internalSession.connect();
        });
    };
    return SessionImpl;
}(topics_1.TopicsImpl));
exports.SessionImpl = SessionImpl;
