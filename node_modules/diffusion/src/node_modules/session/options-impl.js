"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable-next-line:strict-type-predicates
var DEFAULT_HOST = (typeof window !== 'undefined' && window.location.hostname)
    ? window.location.hostname
    : 'localhost';
// tslint:disable-next-line:strict-type-predicates
var DEFAULT_PORT = (typeof window !== 'undefined'
    && window.location.protocol === 'http:'
    && window.location.port)
    ? parseInt(window.location.port, 10)
    : 80;
// tslint:disable-next-line:strict-type-predicates
var DEFAULT_SECURE_PORT = (typeof window !== 'undefined'
    && window.location.protocol === 'https:'
    && window.location.port)
    ? parseInt(window.location.port, 10)
    : 443;
// tslint:disable-next-line:strict-type-predicates
var DEFAULT_SECURE = typeof window === 'undefined' || window.location.protocol !== 'http:';
var DEFAULT_PATH = '/diffusion';
var DEFAULT_RECONNECT_TIMEOUT = 60000;
var DEFAULT_RECONNECT_STRATEGY = function (start) {
    setTimeout(start, 5000);
};
var DEFAULT_ABORT_STRATEGY = function (start, abort) {
    abort();
};
var DEFAULT_PRINCIPAL = '';
var DEFAULT_PASSWORD = '';
var DEFAULT_ACTIVITY_MONITOR = true;
var DEFAULT_TRANSPORTS = ['WEBSOCKET'];
var DEFAULT_MAX_MESSAGE_SIZE = 2147483647;
var MIN_MAX_MESSAGE_SIZE = 1024;
/**
 * Implementation of the {@link Options} interface.
 *
 * @inheritdoc
 */
var OptionsImpl = /** @class */ (function () {
    /**
     * Create a new OptionsImpl instance
     *
     * The constructor takes a partially defined Options object and sets all
     * undefined properties with their default values.
     *
     * @param  options  the options to create the instance from
     */ // tslint:disable-next-line:cyclomatic-complexity
    function OptionsImpl(options) {
        if (options === void 0) { options = {}; }
        // override options.host and options.port if supplied together
        // in options.host.
        if (options.host === undefined) {
            options.host = DEFAULT_HOST;
        }
        else if (options.host.indexOf(':') > -1) {
            var parts = options.host.split(':');
            if (options.port === undefined) {
                options.port = parseInt(parts[1], 10);
            }
            options.host = parts[0];
        }
        if (options.path === undefined) {
            options.path = DEFAULT_PATH;
        }
        else {
            if (options.path[0] !== '/') {
                options.path = '/' + options.path;
            }
            // assert that the path ends with '/diffusion'
            if (options.path.substring(options.path.length - DEFAULT_PATH.length) !== DEFAULT_PATH) {
                if (options.path[options.path.length - 1] === '/') {
                    options.path = options.path.substring(0, options.path.length - 1);
                }
                options.path = options.path + DEFAULT_PATH;
            }
        }
        if (options.port !== undefined) {
            if (typeof options.port === 'string') {
                if (isNaN(parseInt(options.port, 10))) {
                    // set to undefined in order to let us derive 'secure' option correctly
                    options.port = undefined;
                }
                else {
                    options.port = parseInt(options.port, 10);
                }
            }
        }
        if (options.secure === undefined) {
            if (options.port === undefined) { // default to secure on secure port.
                options.secure = DEFAULT_SECURE;
            }
            else { // if specified port 80, default to insecure else secure.
                options.secure = options.port === DEFAULT_SECURE_PORT ? true : false;
            }
        }
        if (options.port === undefined) {
            // security specified but not port, choose 443 or 80?
            options.port = options.secure ? DEFAULT_SECURE_PORT : DEFAULT_PORT;
        }
        this.host = options.host;
        this.port = options.port;
        this.path = options.path;
        this.secure = options.secure;
        if (options.reconnect === undefined || (typeof options.reconnect === 'boolean') && options.reconnect) {
            this.reconnect = {
                timeout: DEFAULT_RECONNECT_TIMEOUT,
                strategy: DEFAULT_RECONNECT_STRATEGY
            };
        }
        else if (typeof options.reconnect === 'number') {
            this.reconnect = {
                timeout: options.reconnect,
                strategy: DEFAULT_RECONNECT_STRATEGY
            };
        }
        else if (typeof options.reconnect === 'function') {
            this.reconnect = {
                timeout: DEFAULT_RECONNECT_TIMEOUT,
                strategy: options.reconnect
            };
        }
        else if (typeof options.reconnect === 'object') {
            this.reconnect = {
                // tslint:disable-next-line:strict-type-predicates
                timeout: options.reconnect.timeout === undefined
                    ? DEFAULT_RECONNECT_TIMEOUT
                    : options.reconnect.timeout,
                strategy: options.reconnect.strategy || DEFAULT_RECONNECT_STRATEGY
            };
        }
        else {
            this.reconnect = {
                timeout: 0,
                strategy: DEFAULT_ABORT_STRATEGY
            };
        }
        if (options.principal !== undefined) {
            this.principal = options.principal || DEFAULT_PRINCIPAL;
            if (typeof options.credentials === 'string') {
                this.credentials = options.credentials;
            }
            else if (isTypedArray(options.credentials)) {
                this.credentials = Buffer.from(options.credentials.buffer);
            }
            else if (Array.isArray(options.credentials)) {
                ensureOctetArray(options.credentials);
                this.credentials = Buffer.from(options.credentials);
            }
            else {
                this.credentials = DEFAULT_PASSWORD;
            }
        }
        if (typeof options.transports === 'string') {
            this.transports = [options.transports];
        }
        else if (typeof options.transports === 'object' &&
            options.transports instanceof Array &&
            options.transports.length > 0) {
            this.transports = options.transports.slice();
        }
        else {
            this.transports = DEFAULT_TRANSPORTS.slice();
        }
        this.transports = this.transports.slice().map(function (t) {
            return t.toUpperCase();
        });
        var mms = (options.maxMessageSize && options.maxMessageSize > MIN_MAX_MESSAGE_SIZE)
            ? options.maxMessageSize
            : DEFAULT_MAX_MESSAGE_SIZE;
        this.maxMessageSize = mms;
        // tslint:disable-next-line:strict-type-predicates
        this.activityMonitor = (options.activityMonitor !== undefined)
            ? options.activityMonitor
            : DEFAULT_ACTIVITY_MONITOR;
        if (options.properties !== undefined) {
            var properties_1 = {};
            Object.getOwnPropertyNames(options.properties).forEach(function (key) {
                // tslint:disable-next-line:strict-type-predicates
                if (typeof options.properties[key] === 'string') {
                    properties_1[key] = options.properties[key];
                }
            });
            this.properties = properties_1;
        }
        this.httpProxyAgent = options.httpProxyAgent;
    }
    /**
     * Create a new Options object containing the union of this with additional
     * options.
     *
     * @param  options  options to merge
     * @returns         the new options
     */
    OptionsImpl.prototype.with = function (options) {
        var e_1, _a, e_2, _b;
        var o = {};
        var k;
        try {
            for (var _c = __values(Object.getOwnPropertyNames(this)), _d = _c.next(); !_d.done; _d = _c.next()) {
                k = _d.value;
                o[k] = this[k];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var _e = __values(Object.getOwnPropertyNames(options)), _f = _e.next(); !_f.done; _f = _e.next()) {
                k = _f.value;
                o[k] = options[k];
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return new OptionsImpl(o);
    };
    return OptionsImpl;
}());
exports.OptionsImpl = OptionsImpl;
/**
 * Ensure that the array contains only octet numbers
 *
 * @param  value  the array to check
 * @throws        an error if any entry in the array is not a number or out of
 *                range
 */
function ensureOctetArray(value) {
    value.forEach(function (element) {
        // tslint:disable-next-line:strict-type-predicates
        if (typeof element !== 'number' || element > 127 || element < -128) {
            throw new Error('Custom credentials invalid. Element must be octet.');
        }
    });
}
/**
 * Check if the argument is a typed array
 *
 * @param  obj  the object to check
 * @return      `true` if the object is an instance of a typed array
 */
function isTypedArray(obj) {
    return (obj instanceof Int8Array ||
        obj instanceof Int16Array ||
        obj instanceof Int32Array ||
        obj instanceof Uint8Array ||
        obj instanceof Uint8ClampedArray ||
        obj instanceof Uint16Array ||
        obj instanceof Uint32Array ||
        obj instanceof Float32Array ||
        obj instanceof Float64Array);
}
