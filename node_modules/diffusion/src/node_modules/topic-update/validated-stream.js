"use strict";
/**
 * @module TopicUpdate
 */
Object.defineProperty(exports, "__esModule", { value: true });
var library_1 = require("core-js/library");
var update_stream_request_1 = require("services/topic-update/update-stream-request");
var invalid_unset_stream_1 = require("topic-update/invalid-unset-stream");
var set_stream_1 = require("topic-update/set-stream");
var logger = require("util/logger");
var topic_update_1 = require("../../topic-update/topic-update");
var log = logger.create('diffusion.TopicUpdate');
/**
 * An update stream delegate that is used when a {@link validate} operation has
 * completed successfully but no {@link set} operation has yet been requested.
 */
var ValidatedStream = /** @class */ (function () {
    /**
     * Create a new SetStream instance
     *
     * @param streamServices   the stream services
     * @param options          the update stream options
     * @param stream           the stream that using this stream as a delegate
     * @param streamId         the stream ID
     */
    function ValidatedStream(streamServices, options, stream, streamId) {
        this.streamServices = streamServices;
        this.options = options;
        this.stream = stream;
        this.streamId = streamId;
    }
    ValidatedStream.prototype.set = function (value) {
        var _this = this;
        this.options.checkOperation(value);
        return new library_1.Promise(function (resolve, reject) {
            _this.stream.setDelegate(new set_stream_1.SetStream(_this.streamServices, _this.options, _this.stream, _this.streamId, value));
            var buffer = _this.options.dataType.toBytes(value).asBuffer();
            _this.streamServices.STREAM_SET_TOPIC_SERVICE.send(new update_stream_request_1.UpdateStreamRequest(_this.streamId, buffer), function (err) {
                if (err) {
                    log.debug('Stream set topic failed');
                    _this.stream.onSetFailed(err);
                    reject(err);
                }
                else {
                    _this.stream.onSetComplete(_this.streamId);
                    resolve();
                }
            });
        });
    };
    /**
     * @inheritdoc
     */
    ValidatedStream.prototype.get = function () {
        throw new Error('The set method has not been called');
    };
    /**
     * @inheritdoc
     */
    ValidatedStream.prototype.validate = function () {
        var _this = this;
        return new library_1.Promise(function (resolve, reject) {
            _this.streamServices.CHECK_UPDATE_STREAM.send(_this.streamId, function (err) {
                if (err) {
                    log.debug('Validate update stream failed');
                    _this.stream.onValidateFailed(err);
                    reject(err);
                }
                else {
                    _this.stream.onValidateComplete(_this.streamId);
                    resolve(topic_update_1.TopicCreationResult.EXISTS);
                }
            });
        });
    };
    /**
     * @inheritdoc
     */
    ValidatedStream.prototype.onSetComplete = function () {
        throw new Error('The set method has not been called');
    };
    /**
     * @inheritdoc
     */
    ValidatedStream.prototype.onSetFailed = function () {
        throw new Error('The set method has not been called');
    };
    /**
     * @inheritdoc
     */
    ValidatedStream.prototype.onValidateComplete = function () {
        // no-op
    };
    /**
     * @inheritdoc
     */
    ValidatedStream.prototype.onValidateFailed = function (err) {
        this.stream.setDelegate(new invalid_unset_stream_1.InvalidUnsetStream(err));
    };
    return ValidatedStream;
}());
exports.ValidatedStream = ValidatedStream;
