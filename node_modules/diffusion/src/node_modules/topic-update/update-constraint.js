"use strict";
/**
 * @module TopicUpdate
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var library_1 = require("core-js/library");
var datatypes_1 = require("data/datatypes");
var json_pointer_1 = require("data/json/json-pointer");
var require_non_null_1 = require("util/require-non-null");
/**
 * Enum mapping the different constraint types to their protocol code
 */
var ConstraintType;
(function (ConstraintType) {
    ConstraintType[ConstraintType["UNCONSTRAINED"] = 0] = "UNCONSTRAINED";
    ConstraintType[ConstraintType["CONJUNCTION"] = 1] = "CONJUNCTION";
    ConstraintType[ConstraintType["BINARY_VALUE"] = 2] = "BINARY_VALUE";
    ConstraintType[ConstraintType["NO_VALUE"] = 3] = "NO_VALUE";
    ConstraintType[ConstraintType["LOCKED"] = 4] = "LOCKED";
    ConstraintType[ConstraintType["NO_TOPIC"] = 5] = "NO_TOPIC";
    ConstraintType[ConstraintType["PARTIAL_JSON"] = 6] = "PARTIAL_JSON";
})(ConstraintType = exports.ConstraintType || (exports.ConstraintType = {}));
/**
 * Base implementation of {@link UpdateConstraint} that implements only
 * the  {@link UpdateConstraint.and and} method but no other functionality
 */
var UpdateConstraintImpl = /** @class */ (function () {
    function UpdateConstraintImpl() {
    }
    /**
     * @inheritdoc
     */
    UpdateConstraintImpl.prototype.and = function (other) {
        if (!library_1.Array.isArray(other)
            && other.getConstraintType() === 'CONJUNCTION') {
            return other.and(this);
        }
        var constraints = library_1.Array.isArray(other) ? other.concat(this) : [this, other];
        checkSatisfiability(constraints);
        /* tslint:disable-next-line:no-use-before-declare */
        return new Conjunction(constraints);
    };
    return UpdateConstraintImpl;
}());
exports.UpdateConstraintImpl = UpdateConstraintImpl;
/**
 * Unconstrained update constraint
 */
var Unconstrained = /** @class */ (function (_super) {
    __extends(Unconstrained, _super);
    function Unconstrained() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get the constraint type
     *
     * @return  `'UNCONSTRAINED'`
     */
    Unconstrained.prototype.getConstraintType = function () {
        return 'UNCONSTRAINED';
    };
    return Unconstrained;
}(UpdateConstraintImpl));
exports.Unconstrained = Unconstrained;
/**
 * A conjunction update constraint that is fulfilled only when all of its
 * member constraints are fulfilled
 */
var Conjunction = /** @class */ (function () {
    /**
     * Create a new Conjunction instance
     *
     * @param constraints  the member constraints which are ANDed together
     */
    function Conjunction(constraints) {
        checkSatisfiability(constraints);
        this.constraints = constraints;
    }
    /**
     * @inheritdoc
     */
    Conjunction.prototype.and = function (other) {
        if (!library_1.Array.isArray(other)
            && other.getConstraintType() === 'CONJUNCTION') {
            return other.and(this.constraints);
        }
        var newConstraints = this.constraints.concat(other);
        checkSatisfiability(newConstraints);
        return new Conjunction(newConstraints);
    };
    /**
     * Get the member constraints
     *
     * @return  a copy of the member constraints
     */
    Conjunction.prototype.getConstraints = function () {
        return this.constraints.slice();
    };
    /**
     * Get the constraint type
     *
     * @return  `'CONJUNCTION'`
     */
    Conjunction.prototype.getConstraintType = function () {
        return 'CONJUNCTION';
    };
    return Conjunction;
}());
exports.Conjunction = Conjunction;
/**
 * A Constraint requiring the current value of the topic to match a specific
 * value.
 */
var BinaryValue = /** @class */ (function (_super) {
    __extends(BinaryValue, _super);
    /**
     * Create a new BinaryValue instance
     *
     * @param bytes  the value that the topic needs to match
     */
    function BinaryValue(bytes) {
        var _this = _super.call(this) || this;
        _this.bytes = bytes;
        return _this;
    }
    /**
     * Get the binary representation of the value
     *
     * @return  the bytes containing the value
     */
    BinaryValue.prototype.getBytes = function () {
        return this.bytes;
    };
    /**
     * Get the constraint type
     *
     * @return  `'BINARY_VALUE'`
     */
    BinaryValue.prototype.getConstraintType = function () {
        return 'BINARY_VALUE';
    };
    return BinaryValue;
}(UpdateConstraintImpl));
exports.BinaryValue = BinaryValue;
/**
 * A constraint requiring a lock to be held by the session.
 */
var Locked = /** @class */ (function (_super) {
    __extends(Locked, _super);
    /**
     * Create a new Locked instance
     *
     * @param lock  the lock that need to be held
     */
    function Locked(lock) {
        var _this = _super.call(this) || this;
        _this.lock = lock;
        _this.lockName = lock.getName();
        _this.sequence = lock.getSequence();
        return _this;
    }
    /**
     * Get the lock name
     *
     * @return  the lock name
     */
    Locked.prototype.getLockName = function () {
        return this.lockName;
    };
    /**
     * Get the lock sequence number
     *
     * @return the lock sequence number
     */
    Locked.prototype.getSequence = function () {
        return this.sequence;
    };
    /**
     * Get the constraint type
     *
     * @return  `'LOCKED'`
     */
    Locked.prototype.getConstraintType = function () {
        return 'LOCKED';
    };
    return Locked;
}(UpdateConstraintImpl));
exports.Locked = Locked;
/**
 * A constraint requiring the path to have no topic
 */
var NoTopic = /** @class */ (function (_super) {
    __extends(NoTopic, _super);
    function NoTopic() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get the constraint type
     *
     * @return  `'NO_TOPIC'`
     */
    NoTopic.prototype.getConstraintType = function () {
        return 'NO_TOPIC';
    };
    return NoTopic;
}(UpdateConstraintImpl));
exports.NoTopic = NoTopic;
/**
 * A constraint requiring the topic to have no value
 */
var NoValue = /** @class */ (function (_super) {
    __extends(NoValue, _super);
    function NoValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get the constraint type
     *
     * @return  `'NO_VALUE'`
     */
    NoValue.prototype.getConstraintType = function () {
        return 'NO_VALUE';
    };
    return NoValue;
}(UpdateConstraintImpl));
exports.NoValue = NoValue;
/**
 * A constraint that partially matches the current JSON topic value
 */
var PartialJSONImpl = /** @class */ (function (_super) {
    __extends(PartialJSONImpl, _super);
    /**
     * Create a new PartialJSONImpl instance
     *
     * @param withValues     the values required to exist in the JSON value
     * @param withoutValues  the JSON pointers that should hold no value
     */
    function PartialJSONImpl(withValues, withoutValues) {
        if (withValues === void 0) { withValues = {}; }
        if (withoutValues === void 0) { withoutValues = new library_1.Set(); }
        var _this = _super.call(this) || this;
        _this.withValues = withValues;
        _this.withoutValues = withoutValues;
        return _this;
    }
    /**
     * Get the required JSON values
     *
     * @return the a map of JSON values that are required
     */
    PartialJSONImpl.prototype.getWithValues = function () {
        return library_1.Object.assign({}, this.withValues);
    };
    /**
     * Get the JSON pointer expressions that should be empty in the JSON value
     *
     * @return  a set of pointer expressions
     */
    PartialJSONImpl.prototype.getWithoutValues = function () {
        return new library_1.Set(this.withoutValues);
    };
    /**
     * @inheritdoc
     */
    PartialJSONImpl.prototype.with = function (pointer, value, dataType) {
        var valueType = ((dataType !== undefined)
            ? dataType
            : datatypes_1.DataTypes.getByValue(value));
        if (valueType === undefined) {
            throw new Error('Datatype invalid or could not be inferred');
        }
        require_non_null_1.requireNonNull(value, 'value');
        json_pointer_1.JSONPointer.parse(require_non_null_1.requireNonNull(pointer, 'pointer'));
        var withProperty = {};
        withProperty[pointer.toString()] = valueType.toBytes(value);
        var newWithValues = library_1.Object.assign({}, this.withValues, withProperty);
        return new PartialJSONImpl(newWithValues, this.withoutValues);
    };
    /**
     * @inheritdoc
     */
    PartialJSONImpl.prototype.without = function (pointer) {
        json_pointer_1.JSONPointer.parse(require_non_null_1.requireNonNull(pointer, 'pointer'));
        var newWithoutValues = new library_1.Set(this.withoutValues);
        newWithoutValues.add(pointer.toString());
        return new PartialJSONImpl(this.withValues, newWithoutValues);
    };
    /**
     * Get the constraint type
     *
     * @return  `'PARTIAL_JSON'`
     */
    PartialJSONImpl.prototype.getConstraintType = function () {
        return 'PARTIAL_JSON';
    };
    return PartialJSONImpl;
}(UpdateConstraintImpl));
exports.PartialJSONImpl = PartialJSONImpl;
/**
 * Check the satisfiability of applying a number of constraints.
 *
 * @param constraints   the constraints that are ANDed together
 * @throws              an error if multiple constraints constrain the topic
 *                      value
 */
function checkSatisfiability(constraints) {
    var previousConstraintOnValue;
    constraints.forEach(function (constraint) {
        if (isConstraintOnTopic(constraint)) {
            if (previousConstraintOnValue !== undefined) {
                throw new Error("Multiple value constraints found: " + previousConstraintOnValue + " and " + constraint);
            }
            else {
                previousConstraintOnValue = constraint;
            }
        }
    });
}
/**
 * Check if the constraint constrains the topic value
 *
 * @param constraint  the constraint to check
 * @return            `true` if the constraint type is one of
 *                    `'BINARY_VALUE', 'NO_VALUE', 'NO_TOPIC', 'PARTIAL_JSON'`
 */
function isConstraintOnTopic(constraint) {
    switch (constraint.getConstraintType()) {
        case 'BINARY_VALUE':
        case 'NO_VALUE':
        case 'NO_TOPIC':
        case 'PARTIAL_JSON':
            return true;
        default:
            return false;
    }
}
