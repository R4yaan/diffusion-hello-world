"use strict";
/**
 * @module Services.Timeseries
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var datatypes_1 = require("data/datatypes");
var Codec = require("io/codec");
var Long = require("long");
var serialiser_1 = require("serialisers/serialiser");
var range_query_result_1 = require("./range-query-result");
var time_series_event_1 = require("./time-series-event");
var time_series_event_metadata_1 = require("./time-series-event-metadata");
var ORIGINAL_EVENT = 0;
var EDIT_EVENT = 1;
var METADATA_OFFSETS = 2;
var AUTHOR_ENCODING = 3;
/**
 * Offsets of a range query result in the time series
 */
var Offsets = /** @class */ (function () {
    /**
     * Create a new Offsets instance
     *
     * @param  sequence   the sequence number offset
     * @param  timestamp  the time offset
     */
    function Offsets(sequence, timestamp) {
        this.sequence = sequence;
        this.timestamp = timestamp;
    }
    return Offsets;
}());
/**
 * Read event metadata
 *
 * @param bis           the input stream
 * @param offsets       the offsets of the range in the result
 * @param codeToAuthor  a mapping between author codes and authors
 * @return              the metadata that was read
 */
function readMetadata(input, offsets, codeToAuthor) {
    var sequence = Codec.readInt64(input).add(offsets.sequence);
    var timestamp = Codec.readInt64(input).add(offsets.timestamp);
    var code = Codec.readBytes(input);
    var decoded = codeToAuthor[code.toString()];
    var author = decoded ? decoded : code.toString('utf-8');
    return new time_series_event_metadata_1.EventMetadataImpl(sequence.toNumber(), timestamp.toNumber(), author);
}
/**
 * Read an original event
 *
 * @param bis           the input stream
 * @param offsets       the offsets of the range in the result
 * @param codeToAuthor  a mapping between author codes and authors
 * @return              the original event that was read
 */
function readOriginalEvent(bis, offsets, codeToAuthor) {
    var metadata = readMetadata(bis, offsets, codeToAuthor);
    return time_series_event_1.EventImpl.create(metadata, metadata, Codec.readBytes(bis));
}
/**
 * Read an edit event
 *
 * @param bis           the input stream
 * @param offsets       the offsets of the range in the result
 * @param codeToAuthor  a mapping between author codes and authors
 * @return              the edit event that was read
 */
function readEditEvent(bis, offsets, codeToAuthor) {
    var originalEvent = readMetadata(bis, offsets, codeToAuthor);
    var metadata = readMetadata(bis, offsets, codeToAuthor);
    return time_series_event_1.EventImpl.create(metadata, originalEvent, Codec.readBytes(bis));
}
/**
 * Read time series offsets
 *
 * @param bis  the input stream
 * @return     the offsets of the range in the result that were read
 */
function readMetadataOffsets(bis) {
    return new Offsets(Codec.readInt64(bis), Codec.readInt64(bis));
}
/**
 * Read the author encoding an store it in the `codeToAuthor` map
 *
 * @param bis           the input stream
 * @param codeToAuthor  a mapping between author codes and authors
 */
function readAuthorEncoding(bis, codeToAuthor) {
    var code = Codec.readBytes(bis);
    codeToAuthor[code.toString()] = Codec.readString(bis);
}
/**
 * Serialiser for {@link RangeQueryResult}
 */
var RangeQueryResultSerialiserClass = /** @class */ (function (_super) {
    __extends(RangeQueryResultSerialiserClass, _super);
    function RangeQueryResultSerialiserClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Read a {@link RangeQueryResult} from the stream
     *
     * @param bis  the input stream
     * @return     the {@link RangeQueryResult} that was read
     */
    RangeQueryResultSerialiserClass.prototype.read = function (input) {
        var dataType = datatypes_1.DataTypes.get(Codec.readString(input));
        if (dataType === null) {
            throw new Error('Received unexpected data type');
        }
        var selectedCount = Codec.readInt64(input);
        var offsets = new Offsets(Long.ZERO, Long.ZERO);
        var codeToAuthor = {};
        var events = [];
        var limit = Codec.readInt32(input);
        for (var i = 0; i < limit; ++i) {
            switch (Codec.readByte(input)) {
                case ORIGINAL_EVENT:
                    events.push(readOriginalEvent(input, offsets, codeToAuthor));
                    break;
                case EDIT_EVENT:
                    events.push(readEditEvent(input, offsets, codeToAuthor));
                    break;
                case METADATA_OFFSETS:
                    offsets = readMetadataOffsets(input);
                    break;
                case AUTHOR_ENCODING:
                    readAuthorEncoding(input, codeToAuthor);
                    break;
                default:
                    readAuthorEncoding(input, codeToAuthor);
            }
        }
        return new range_query_result_1.RangeQueryResult(dataType, selectedCount, events);
    };
    return RangeQueryResultSerialiserClass;
}(serialiser_1.AbstractSerialiser));
exports.RangeQueryResultSerialiserClass = RangeQueryResultSerialiserClass;
/**
 * The {@link RangeQueryResultSerialiser} singleton
 */ // tslint:disable-next-line:variable-name
exports.RangeQueryResultSerialiser = new RangeQueryResultSerialiserClass();
