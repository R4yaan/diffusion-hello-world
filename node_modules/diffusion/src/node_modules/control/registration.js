"use strict";
/**
 * @module Control
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var close_reason_1 = require("client/close-reason");
var library_1 = require("core-js/library");
var Services = require("services/services");
var Logger = require("util/logger");
var logger = Logger.create('Registration');
/**
 * State of a response handler
 */
var ResponseHandlerState;
(function (ResponseHandlerState) {
    ResponseHandlerState[ResponseHandlerState["REGISTERING"] = 0] = "REGISTERING";
    ResponseHandlerState[ResponseHandlerState["ACTIVE"] = 1] = "ACTIVE";
    ResponseHandlerState[ResponseHandlerState["CLOSED"] = 2] = "CLOSED";
})(ResponseHandlerState = exports.ResponseHandlerState || (exports.ResponseHandlerState = {}));
/**
 * An error that indicating that a user defined handler has thrown an exception.
 */
var RegisteredHandlerException = /** @class */ (function (_super) {
    __extends(RegisteredHandlerException, _super);
    /**
     * Create a RegisteredHandlerException
     *
     * @param  cause     the exception thrown by the user defined handler
     * @param  ...args   additional parameters passed to the `Error` constructor
     */
    function RegisteredHandlerException(cause) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _this = _super.apply(this, __spread(args)) || this;
        _this.cause = cause;
        return _this;
    }
    return RegisteredHandlerException;
}(Error));
/**
 * Create a new response handler
 *
 * @param  internal        the internal session
 * @param  adapter         the registration adapter
 * @param  deregistration  the deregistration callback
 * @return                 a new response handler
 */
function responseHandler(internal, adapter, deregistration) {
    var state = ResponseHandlerState.REGISTERING;
    var close;
    return {
        onDiscard: function (cid, err) {
            try {
                if (err instanceof close_reason_1.CloseReasonImpl) {
                    adapter.close();
                }
                else {
                    adapter.close(err);
                }
            }
            catch (err) {
                logger.error('REGISTERED_HANDLER_EXCEPTION', err);
            }
            state = ResponseHandlerState.CLOSED;
        },
        onOpen: function (cid) {
            close = function () {
                return new library_1.Promise(function (resolve, reject) {
                    if (state !== ResponseHandlerState.CLOSED) {
                        deregistration(cid, function (err) {
                            if (err) {
                                internal.getConversationSet().discard(cid, err);
                                reject(err);
                            }
                            else {
                                internal.getConversationSet().respondIfPresent(cid, ResponseHandlerState.CLOSED);
                                resolve();
                            }
                        });
                    }
                    else {
                        reject(new Error('Handler already closed'));
                    }
                });
            };
        },
        onResponse: function (cid, response) {
            if (response === ResponseHandlerState.CLOSED) {
                try {
                    adapter.close();
                }
                catch (err) {
                    logger.error('REGISTERED_HANDLER_EXCEPTION', err);
                }
                state = response;
                return true;
            }
            try {
                if (response === ResponseHandlerState.ACTIVE) {
                    adapter.active(close, cid);
                    state = response;
                    return false;
                }
                else {
                    return adapter.respond(response);
                }
            }
            catch (err) {
                logger.error('REGISTERED_HANDLER_EXCEPTION', err);
                internal.getConversationSet().discard(cid, new RegisteredHandlerException(err, 'An error was thrown by the handler'));
                close().catch(function (closeErr) {
                    logger.debug('Failed to deregister with the server', closeErr);
                });
            }
            return true;
        }
    };
}
exports.responseHandler = responseHandler;
/**
 * Create a registration callback function
 *
 * @param conversationSet  the conversation set
 * @param cid              the conversation ID
 * @param emitter          the emitter to emit events on
 * @return                 a new registration callback function
 */
function registrationCallback(conversationSet, cid, resolve, reject) {
    return function (err) {
        if (err) {
            conversationSet.discard(cid, err);
            reject(err);
        }
        else {
            conversationSet.respondIfPresent(cid, ResponseHandlerState.ACTIVE);
            resolve();
        }
    };
}
exports.registrationCallback = registrationCallback;
/**
 * Register a handler with the conversation set.
 *
 * @param internal  the internal session
 * @param params    the registration parameters to send to the server
 * @param adapter   the registration adapter
 * @param reg       the registration service that is used to register with the server
 * @param dereg     the deregistration service that is used to deregister with the server
 */
function registerHandler(internal, params, adapter, reg, dereg) {
    var conversationSet = internal.getConversationSet();
    var serviceLocator = internal.getServiceLocator();
    var registration = serviceLocator.obtain(reg);
    var deregistration = serviceLocator.obtain(dereg);
    var cid = conversationSet.newConversation(responseHandler(internal, adapter, function (conversationId, callback) {
        deregistration.send(params, callback);
    }));
    return new library_1.Promise(function (resolve, reject) {
        registration.send({ params: params, cid: cid }, registrationCallback(conversationSet, cid, resolve, reject));
    });
}
exports.registerHandler = registerHandler;
/**
 * Register a handler for messages
 *
 * @param internal  the internal session
 * @param params    the registration parameters to send to the server
 * @param adapter   the registration adapter
 */
function registerMessageHandler(internal, params, adapter) {
    return registerHandler(internal, params, adapter, Services.MESSAGE_RECEIVER_CONTROL_REGISTRATION, Services.MESSAGE_RECEIVER_CONTROL_DEREGISTRATION);
}
exports.registerMessageHandler = registerMessageHandler;
/**
 * Register a handler for the messaging service
 *
 * @param internal  the internal session
 * @param params    the registration parameters to send to the server
 * @param adapter   the registration adapter
 */
function registerRequestHandler(internal, params, adapter) {
    return registerHandler(internal, params, adapter, Services.MESSAGING_RECEIVER_CONTROL_REGISTRATION, Services.MESSAGING_RECEIVER_CONTROL_DEREGISTRATION);
}
exports.registerRequestHandler = registerRequestHandler;
/**
 * Register a handler for topic control notifications
 *
 * @param internal  the internal session
 * @param params    the registration parameters to send to the server
 * @param adapter   the registration adapter
 */
function registerTopicHandler(internal, params, adapter) {
    return registerHandler(internal, params, adapter, Services.TOPIC_CONTROL_REGISTRATION, Services.TOPIC_CONTROL_DEREGISTRATION);
}
exports.registerTopicHandler = registerTopicHandler;
