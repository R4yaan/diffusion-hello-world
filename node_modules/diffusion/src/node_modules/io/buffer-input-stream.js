"use strict";
/**
 * @module IO
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Long = require("long");
/**
 * Sequential reading of values from a given Buffer.
 * Loosely inspired by Java's ByteArrayInputStream.
 */
var BufferInputStream = /** @class */ (function () {
    /**
     * Construct an input stream from a Buffer
     *
     * @param {Buffer} buffer - The source Buffer.
     */
    function BufferInputStream(buffer) {
        this.buffer = buffer;
        this.count = buffer.length;
        this.pos = 0;
    }
    /**
     * Read one byte.
     * @returns The byte that was read, or -1 if the stream is exhausted.
     */
    BufferInputStream.prototype.read = function () {
        /* tslint:disable-next-line:no-bitwise */
        return (this.pos < this.count) ? (this.buffer[this.pos++] & 0xFF) : -1;
    };
    /**
     * Returns the next byte in the input stream, without extracting it.
     *
     * @returns The byte that was read, or -1 if the stream is exhausted.
     */
    BufferInputStream.prototype.peek = function () {
        /* tslint:disable-next-line:no-bitwise */
        return (this.pos < this.count) ? (this.buffer[this.pos] & 0xFF) : -1;
    };
    /**
     * Read a specified amount of bytes.
     *
     * If the length is greater than the remaining number of bytes, this function
     * will read up to the last available byte in the buffer.
     *
     * @param length the number of bytes you wish to read.
     * @returns the bytes that have been read
     * @throws will throw an OutOfBounds error if length is a negative number.
     */
    BufferInputStream.prototype.readMany = function (length) {
        var lengthAdjusted = Math.min(length, this.count - this.pos);
        if (lengthAdjusted < 0) {
            throw new Error('Length out of bounds');
        }
        var result = this.buffer.slice(this.pos, this.pos + lengthAdjusted);
        this.pos += lengthAdjusted;
        return result;
    };
    /**
     * Read until a specified byte (delimiter) is found.
     *
     * The buffer position is updated to point to just after the
     * delimiter.
     *
     * If the delimiter can't be found, then return all bytes until the
     * end of the buffer.
     *
     * @param delim the delimiter byte
     * @returns a buffer containing the bytes up to but not including the
     *          delimiter byte.
     */
    BufferInputStream.prototype.readUntil = function (delim) {
        var found = this.count;
        for (var i = this.pos; i < this.count; i++) {
            if (this.buffer[i] === delim) {
                found = i;
                break;
            }
        }
        var buffer = this.buffer.slice(this.pos, found);
        this.pos = (found === this.count) ? found : found + 1;
        return buffer;
    };
    /**
     * Read a signed 8-bit integer.
     * @returns the number that has been read.
     */
    BufferInputStream.prototype.readInt8 = function () {
        return this.buffer.readInt8(this.pos++);
    };
    /**
     * Read a signed, big-endian 32-bit integer.
     * @returns the number that has been read.
     */
    BufferInputStream.prototype.readInt32 = function () {
        var i = this.buffer.readInt32BE(this.pos);
        this.pos += 4;
        return i;
    };
    /**
     * Read a signed, big-endian 64-bit long.
     * @returns the number that has been read.
     */
    BufferInputStream.prototype.readInt64 = function () {
        var hi = this.buffer.readInt32BE(this.pos);
        this.pos += 4;
        var lo = this.buffer.readInt32BE(this.pos);
        this.pos += 4;
        return Long.fromBits(lo, hi, false);
    };
    /**
     * Read an unsigned, big-endian 64-bit long.
     * @returns the number that has been read.
     */
    BufferInputStream.prototype.readUInt64 = function () {
        var hi = this.buffer.readInt32BE(this.pos);
        this.pos += 4;
        var lo = this.buffer.readInt32BE(this.pos);
        this.pos += 4;
        return Long.fromBits(lo, hi, true);
    };
    /**
     * Indicates if there are remaining bytes to be found
     *
     * @returns `true` if there are remaining bytes
     */
    BufferInputStream.prototype.hasRemaining = function () {
        return this.pos < this.buffer.length;
    };
    return BufferInputStream;
}());
exports.BufferInputStream = BufferInputStream;
