"use strict";
/**
 * @module IO
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var library_1 = require("core-js/library");
var Long = require("long");
// bitmasks for int64 read/write
var x80 = Long.fromNumber(0x80);
var x7F = Long.fromNumber(0x7F);
// long.not returns a different value than ~
var x7FInv = x7F.not(); // not Long.fromNumber(~0x7F);
/**
 * Read a single byte from the input
 *
 * @param  input the input stream to read from
 * @return       the next byte in the input stream
 * @throws an error if no more data is available
 */
function readByte(input) {
    var i = input.read();
    if (i === -1) {
        throw new Error('End of stream');
    }
    return i;
}
exports.readByte = readByte;
/**
 * Read an encoded Int64
 *
 * This will return the value as a Long instance.
 *
 * @param input the input stream from which to read
 * @returns the decoded Int64, represented as Long
 * @throws an error if an int64 is malformed and cannot be read
 */
function readInt64(input) {
    var result = Long.fromNumber(0);
    var shift = 0;
    while (shift < 64) {
        var i = readByte(input);
        var l = Long.fromNumber(i);
        result = result.or(l.and(x7F).shiftLeft(shift));
        if (l.and(x80).equals(0)) {
            return result;
        }
        shift += 7;
    }
    throw new Error('Malformed int64');
}
exports.readInt64 = readInt64;
/**
 * Write an encoded Int64
 *
 * Writes a number as an Int64 to the given Output stream.
 *
 * @param bos the output stream to write to
 * @param value the number to write
 */
function writeInt64(bos, value) {
    var int64 = value instanceof Long ? value : Long.fromNumber(value, false);
    while (!int64.and(x7FInv).equals(0)) {
        bos.write(int64.and(x7F).or(x80).toInt());
        int64 = int64.shiftRightUnsigned(7);
    }
    bos.write(int64.toInt());
}
exports.writeInt64 = writeInt64;
/**
 * Read an encoded Int32
 *
 * @param bis The input stream to read from
 * @returns the Int32 that was read
 * @throws an error if an int32 is malformed and cannot be read
 */
function readInt32(bis) {
    var shift = 0;
    var result = 0;
    while (shift < 32) {
        var i = readByte(bis);
        /* tslint:disable-next-line:no-bitwise */
        result |= (i & 0x7F) << shift;
        /* tslint:disable-next-line:no-bitwise */
        if ((i & 0x80) === 0) {
            return result;
        }
        shift += 7;
    }
    throw new Error('Malformed int32');
}
exports.readInt32 = readInt32;
/**
 * Write an encoded Int32
 *
 * @param bos the output stream to write to
 * @param value the number to write as an int32
 */
function writeInt32(bos, value) {
    /* tslint:disable-next-line:no-bitwise */
    while ((value & ~0x7F) !== 0) {
        /* tslint:disable-next-line:no-bitwise */
        bos.write((value & 0x7F) | 0x80);
        /* tslint:disable-next-line:no-bitwise */
        value = value >>> 7;
    }
    bos.write(value);
}
exports.writeInt32 = writeInt32;
/**
 * Write a single signed byte
 *
 * @param bos the output stream to write to
 * @param value the byte value to write. Must be between 0 and 255
 */
function writeByte(bos, value) {
    bos.write(value);
}
exports.writeByte = writeByte;
/**
 * Read bytes as a Buffer
 *
 * @param bis the input stream to read from
 * @returns the bytes that were read
 */
function readBytes(bis) {
    var length = readInt32(bis);
    return bis.readMany(length);
}
exports.readBytes = readBytes;
/**
 * Write multiple bytes
 *
 * @param bos the output stream to write to
 * @param value the bytes to be written
 */
function writeBytes(bos, value) {
    writeInt32(bos, value.length);
    bos.writeMany(value);
}
exports.writeBytes = writeBytes;
/**
 * Read a UTF-8 encoded String
 *
 * @param bis the input stream to read from
 * @returns the string that was read
 */
function readString(bis) {
    var buffer = readBytes(bis);
    return buffer ? buffer.toString('utf8') : '';
}
exports.readString = readString;
/**
 * Write a string using UTF-8 encoding
 *
 * @param bos the output stream to write to
 * @param value the string to write
 */
function writeString(bos, value) {
    writeBytes(bos, Buffer.from(value, 'utf8'));
}
exports.writeString = writeString;
/**
 * Write a collection of objects, using a specific writer function
 *
 * @param bos the output stream to write to
 * @param arr array of values
 * @param write writer function
 * @param <T> the type of data in the collection
 */
function writeCollection(bos, arr, write) {
    var e_1, _a;
    writeInt32(bos, arr.length);
    try {
        for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
            var val = arr_1_1.value;
            write(bos, val);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
exports.writeCollection = writeCollection;
/**
 * Read a collection of objects, using a specific reader function
 *
 * @param bis the input stream to read from
 * @param read the reader function
 * @returns an array of read values
 * @param <T> the type of data in the collection
 */
function readCollection(bis, read) {
    var length = readInt32(bis);
    var arr = [];
    for (var i = 0; i < length; ++i) {
        arr.push(read(bis));
    }
    return arr;
}
exports.readCollection = readCollection;
/**
 * Read a dictionary of strings and values of a given type
 *
 * @param bis the input stream to read from
 * @param read value reader function
 * @returns a dictionary of values
 * @param <T> the type of data stored in the dictionary
 */
function readDictionary(bis, read) {
    return readObject(bis, readString, read);
}
exports.readDictionary = readDictionary;
/**
 * Write a dictionary of strings and values
 *
 * @param bos the output stream to write to
 * @param dict the dictionary of values
 * @param write value writer function
 * @param <T> the type of data stored in the dictionary
 */
function writeDictionary(bos, dict, write) {
    writeObject(bos, dict, writeString, write);
}
exports.writeDictionary = writeDictionary;
/**
 * Write an object of keys/values
 *
 * @param bos the output stream to write to
 * @param dict the map of values
 * @param keyWriter the Key writer function
 * @param valueWriter the Value writer function
 * @param <T> the type of data stored in the object
 * @param <K> the type of the object keys
 */
function writeObject(bos, dict, keyWriter, valueWriter) {
    var e_2, _a;
    writeInt32(bos, Object.keys(dict).length);
    try {
        for (var _b = __values(Object.getOwnPropertyNames(dict)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var k = _c.value;
            keyWriter(bos, k);
            valueWriter(bos, dict[k]);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
}
exports.writeObject = writeObject;
/**
 * Read a map of keys/values as an object
 *
 * @param bos the output stream to write to
 * @param keyReader the key reader function
 * @param valueReader the Value reader function
 * @returns the read map
 * @param <T> the type of data stored in the object
 * @param <K> the type of the object keys
 */
function readObject(bis, keyReader, valueReader) {
    var length = readInt32(bis);
    var dict = {};
    for (var i = 0; i < length; ++i) {
        var k = keyReader(bis);
        dict[k] = valueReader(bis);
    }
    return dict;
}
exports.readObject = readObject;
/**
 * Read a map of keys/values
 *
 * @param bos the output stream to write to
 * @param keyReader the key reader function
 * @param valueReader the Value reader function
 * @returns the read map
 * @param <T> the type of data stored in the map
 * @param <K> the type of the map keys
 */
function readMap(bis, keyReader, valueReader) {
    var length = readInt32(bis);
    var map = new library_1.Map();
    for (var i = 0; i < length; ++i) {
        var k = keyReader(bis);
        map.set(k, valueReader(bis));
    }
    return map;
}
exports.readMap = readMap;
/**
 * Write an object of keys/values
 *
 * @param bos the output stream to write to
 * @param dict the map of values
 * @param keyWriter the Key writer function
 * @param valueWriter the Value writer function
 * @param <T> the type of data stored in the map
 * @param <K> the type of the map keys
 */
function writeMap(bos, map, keyWriter, valueWriter) {
    writeInt32(bos, map.size);
    map.forEach(function (v, k) {
        keyWriter(bos, k);
        valueWriter(bos, v);
    });
}
exports.writeMap = writeMap;
/**
 * Read a boolean value
 *
 * @param bis the input stream to read from
 * @returns the boolean that was read
 */
function readBoolean(bis) {
    var b = bis.readInt8();
    return (b !== 0);
}
exports.readBoolean = readBoolean;
/**
 * Write a boolean value
 *
 * @param bos the output stream to write to
 * @param value the boolean value to write
 */
function writeBoolean(bos, value) {
    bos.writeInt8(value ? 1 : 0);
}
exports.writeBoolean = writeBoolean;
