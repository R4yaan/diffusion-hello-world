"use strict";
/**
 * @module IO
 *
 * @brief Basic stream based input and output using an underlying `Buffer`
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Wrapper around a single Buffer, providing auto-resizing capabilities.
 *
 * All write operations will append to the internal buffer.
 *
 * Loosely inspired by Java's ByteArrayOutputStream.
 */
var BufferOutputStream = /** @class */ (function () {
    /**
     * Create a new output stream from a buffer
     *
     * @param initial the initial size for the internal Buffer, or buffer to use as source.
     */
    function BufferOutputStream(initial) {
        if (initial === void 0) { initial = 32; }
        if (typeof (initial) === 'number') {
            this.buffer = Buffer.alloc(initial);
            this.count = 0;
        }
        else {
            this.buffer = initial;
            this.count = initial.length;
        }
    }
    /**
     * Write a single byte.
     *
     * @param val the byte to append
     */
    BufferOutputStream.prototype.write = function (val) {
        this.ensureCapacity(this.count + 1);
        this.buffer[this.count++] = val;
    };
    /**
     * Write many bytes.
     *
     * The contents of the provided buffer will be copied and appended. The full
     * length of the buffer will be copied, irrespective of byte content.
     *
     * @param buffer - The bytes to append.
     * @param [offset=0] - The offset to start copying from the provided buffer
     * @param [length=buffer.length] - The amount of bytes to copy from the provided buffer
     */
    BufferOutputStream.prototype.writeMany = function (buffer, offset, length) {
        if (offset === void 0) { offset = 0; }
        if (length === void 0) { length = buffer.length; }
        if (length === 0) {
            // nothing to write, just bail out here
            return;
        }
        this.ensureCapacity(this.count + length);
        buffer.copy(this.buffer, this.count, offset, offset + length);
        this.count += length;
    };
    /**
     * Write a String in UTF-8 format.
     *
     * @param val the string value to be appended.
     */
    BufferOutputStream.prototype.writeString = function (val) {
        var length = Buffer.byteLength(val);
        this.ensureCapacity(this.count + length);
        // strings are encoded as UTF-8 by default
        this.buffer.write(val, this.count, length);
        this.count += length;
    };
    /**
     * Write a signed 8-bit integer.
     * @param val the number to write
     */
    BufferOutputStream.prototype.writeInt8 = function (val) {
        this.ensureCapacity(this.count + 1);
        this.buffer.writeInt8(val, this.count++);
    };
    /**
     * Write a signed, big-endian 32-bit integer.
     * @param val the number to write
     */
    BufferOutputStream.prototype.writeInt32 = function (val) {
        this.ensureCapacity(this.count + 4);
        this.buffer.writeInt32BE(val, this.count);
        this.count += 4;
    };
    /**
     * Write a signed, big-endian 64-bit long.
     * @param val the number to write.
     */
    BufferOutputStream.prototype.writeInt64 = function (val) {
        this.ensureCapacity(this.count + 8);
        this.buffer.writeInt32BE(val.getHighBits(), this.count);
        this.buffer.writeInt32BE(val.getLowBits(), this.count + 4);
        this.count += 8;
    };
    /**
     * Return the written bytes as a buffer, sized to the last value written.
     * <p>
     * Any modifications to the returned buffer will be reflected in this OutputStream.
     *
     * @returns A Buffer containing all the bytes current written to this OutputStream.
     */
    BufferOutputStream.prototype.getBuffer = function () {
        return this.buffer.slice(0, this.count);
    };
    /**
     * Return written bytes as a base64 encoded string.
     * @returns The base64 encoded string
     */
    BufferOutputStream.prototype.getBase64 = function () {
        return this.getBuffer().toString('base64');
    };
    /**
     * Ensure that the output stream has enough capacity
     *
     * @param  min the capacity the buffer should have
     */
    BufferOutputStream.prototype.ensureCapacity = function (min) {
        if (min - this.buffer.length > 0) {
            this.grow(min);
        }
    };
    /**
     * Grow the buffer up to the next minimum capacity (or higher).
     *
     * @param minCapacity the minimum capacity required
     * @throws If the new capacity exceeds that with which a Buffer can be created,
     *         an error will be thrown.
     */
    BufferOutputStream.prototype.grow = function (minCapacity) {
        var oldCapacity = this.buffer.length;
        /* tslint:disable-next-line:no-bitwise */
        var newCapacity = oldCapacity << 1;
        if (newCapacity - minCapacity < 0) {
            newCapacity = minCapacity;
        }
        try {
            var replacement = Buffer.alloc(newCapacity);
            this.buffer.copy(replacement);
            this.buffer = replacement;
        }
        catch (e) {
            throw new Error('Unable to resize BufferOutputStream to ' + newCapacity);
        }
    };
    return BufferOutputStream;
}());
exports.BufferOutputStream = BufferOutputStream;
