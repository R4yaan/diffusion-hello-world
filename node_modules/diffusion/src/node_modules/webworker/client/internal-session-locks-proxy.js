"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Long = require("long");
var logger = require("util/logger");
var worker_command_1 = require("webworker/worker-command");
var log = logger.create('InternalSessionLocksProxy');
/**
 * A SessionLock implementation for shared sessions
 */
var SessionLockProxy = /** @class */ (function () {
    function SessionLockProxy(name, sequence, scope, ownedSetter, releaseLock) {
        var _this = this;
        this.owned = true;
        this.name = name;
        this.sequence = sequence;
        this.scope = scope;
        this.releaseLock = releaseLock;
        ownedSetter.setOwned = function (newOwned) {
            _this.owned = newOwned;
        };
    }
    /**
     * @inheritdoc
     */
    SessionLockProxy.prototype.getName = function () {
        return this.name;
    };
    /**
     * @inheritdoc
     */
    SessionLockProxy.prototype.getSequence = function () {
        return this.sequence;
    };
    /**
     * @inheritdoc
     */
    SessionLockProxy.prototype.isOwned = function () {
        return this.owned;
    };
    /**
     * @inheritdoc
     */
    SessionLockProxy.prototype.getScope = function () {
        return this.scope;
    };
    /**
     * @inheritdoc
     */
    SessionLockProxy.prototype.unlock = function () {
        if (this.owned) {
            this.owned = false;
            return this.releaseLock(this);
        }
        else {
            return Promise.resolve(false);
        }
    };
    return SessionLockProxy;
}());
exports.SessionLockProxy = SessionLockProxy;
/**
 * A proxy class that replaces InternalSessionLocks when accessing a shared
 * session
 */
var InternalSessionLocksProxy = /** @class */ (function () {
    function InternalSessionLocksProxy(connector) {
        var _this = this;
        /**
         * Map of pending acquisition requests
         */
        this.activeRequests = {};
        /**
         * Map of pending release requests
         */
        this.releaseRequests = {};
        /**
         * The map of locks indexed by their name
         */
        this.locks = {};
        /**
         * The next request id
         */
        this.nextRequestId = 0;
        this.connector = connector;
        this.connector.on('lock_event', function (eventArgs) {
            var _a = __read(eventArgs, 3), lockName = _a[0], action = _a[1], data = _a[2];
            switch (action) {
                case worker_command_1.WorkerSessionLockCommand.ACQUIRED:
                    _this.onLockAcquired(lockName, data);
                    break;
                case worker_command_1.WorkerSessionLockCommand.ACQUIRE_ERROR:
                    _this.onLockAcquireError(lockName, data);
                    break;
                case worker_command_1.WorkerSessionLockCommand.OWNED:
                    _this.onLockOwned(lockName, data);
                    break;
                case worker_command_1.WorkerSessionLockCommand.REMOVED:
                    _this.onLockRemoved(lockName);
                    break;
                case worker_command_1.WorkerSessionLockCommand.RELEASED:
                    _this.onLockReleased(data);
                    break;
                case worker_command_1.WorkerSessionLockCommand.RELEASE_ERROR:
                    _this.onLockReleaseError(data);
                    break;
                default:
                    log.error("Unrecognised lock_event " + action);
            }
        });
    }
    InternalSessionLocksProxy.prototype.onLockAcquired = function (lockName, data) {
        var _a = __read(data, 3), requestId = _a[0], sequence = _a[1], scope = _a[2];
        // tslint:disable-next-line:strict-type-predicates
        if (this.activeRequests[requestId] !== undefined) {
            this.activeRequests[requestId](undefined, lockName, Long.fromString(sequence, 10), scope);
            delete this.activeRequests[requestId];
        }
    };
    InternalSessionLocksProxy.prototype.onLockAcquireError = function (lockName, data) {
        var _a = __read(data, 2), requestId = _a[0], error = _a[1];
        // tslint:disable-next-line:strict-type-predicates
        if (this.activeRequests[requestId] !== undefined) {
            this.activeRequests[requestId](error, lockName);
            delete this.activeRequests[requestId];
        }
    };
    InternalSessionLocksProxy.prototype.onLockOwned = function (lockName, newOwned) {
        // tslint:disable-next-line:strict-type-predicates
        if (this.locks[lockName] !== undefined) {
            this.locks[lockName].ownedSetter.setOwned(newOwned);
        }
    };
    InternalSessionLocksProxy.prototype.onLockRemoved = function (lockName) {
        delete this.locks[lockName];
    };
    InternalSessionLocksProxy.prototype.onLockReleased = function (data) {
        var _a = __read(data, 2), requestId = _a[0], success = _a[1];
        this.releaseRequests[requestId](undefined, success);
    };
    InternalSessionLocksProxy.prototype.onLockReleaseError = function (data) {
        var _a = __read(data, 2), requestId = _a[0], error = _a[1];
        this.releaseRequests[requestId](error);
    };
    InternalSessionLocksProxy.prototype.handleAcquisition = function (lockName, sequence, scope) {
        var oldLock = this.locks[lockName];
        // tslint:disable-next-line:strict-type-predicates
        if (oldLock !== undefined && oldLock.lock.getSequence().equals(sequence)) {
            return oldLock.lock;
        }
        var sessionLockOwnedSetter = {
            setOwned: function () {
                throw Error('Session lock ownedSetter must be implemented');
            }
        };
        var sessionLock = new SessionLockProxy(lockName, sequence, scope, sessionLockOwnedSetter, this.releaseLock.bind(this));
        this.locks[lockName] = { lock: sessionLock, ownedSetter: sessionLockOwnedSetter };
        return sessionLock;
    };
    InternalSessionLocksProxy.prototype.releaseLock = function (sessionLock) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var requestId = _this.nextRequestId++;
            _this.releaseRequests[requestId] = function (err, success) {
                delete _this.releaseRequests[requestId];
                if (err) {
                    log.debug('Release shared-session lock failed');
                    reject(err);
                }
                else {
                    resolve(success);
                }
            };
            _this.connector.send(worker_command_1.WorkerCommand.LOCK, JSON.stringify({
                action: 'release',
                requestId: requestId,
                name: sessionLock.getName(),
                sequence: sessionLock.getSequence().toString(10),
                scope: sessionLock.getScope()
            }));
        });
    };
    /**
     * Request a session lock
     *
     * @param lockName  the lock name
     * @param scope     the lock scope
     * @return          a {@link Result} that resolves with the acquired session lock
     */
    InternalSessionLocksProxy.prototype.lock = function (lockName, scope) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // tslint:disable-next-line:strict-type-predicates
            if (_this.locks[lockName] !== undefined && _this.locks[lockName].lock.isOwned()) {
                resolve(_this.locks[lockName].lock);
            }
            else {
                var requestId_1 = _this.nextRequestId++;
                _this.activeRequests[requestId_1] = function (err, name, sequence, responseScope) {
                    delete _this.activeRequests[requestId_1];
                    if (err) {
                        log.debug('Acquire shared-session lock failed');
                        reject(err);
                    }
                    else {
                        resolve(_this.handleAcquisition(name, sequence, responseScope));
                    }
                };
                _this.connector.send(worker_command_1.WorkerCommand.LOCK, JSON.stringify({
                    action: 'acquire',
                    requestId: requestId_1,
                    name: lockName,
                    scope: scope
                }));
            }
        });
    };
    return InternalSessionLocksProxy;
}());
exports.InternalSessionLocksProxy = InternalSessionLocksProxy;
