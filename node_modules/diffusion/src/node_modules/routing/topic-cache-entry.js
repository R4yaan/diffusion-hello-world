"use strict";
/**
 * @module Routing
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Arrays = require("util/array");
var topics_1 = require("../../topics/topics");
/**
 * An entry for the topic cache
 */
var TopicCacheEntry = /** @class */ (function () {
    /**
     * Create a new TopicCacheEntry instance
     *
     * @param streams        the stream adapters
     * @param path           the topic path
     * @param specification  the topic specification
     */
    function TopicCacheEntry(streams, path, specification) {
        this.streams = streams;
        this.path = path;
        this.specification = specification;
    }
    /**
     * Get the stream adapters
     *
     * If there are no streams in this entry, this will return the fallback streams
     * that match the topic details
     *
     * @param specification   the topic specficiation
     * @param registry  the stream registry
     */
    TopicCacheEntry.prototype.proxies = function (specification, registry) {
        return (this.streams.length === 0)
            ? registry.getFallbacks(specification)
            : this.streams;
    };
    /**
     * Get the topic path
     *
     * @return  the topic path
     */
    TopicCacheEntry.prototype.getTopicPath = function () {
        return this.path;
    };
    /**
     * Get the topic specification
     *
     * @return  the topic specification
     */
    TopicCacheEntry.prototype.getTopicSpecification = function () {
        return this.specification;
    };
    /**
     * Notify all streams of the initial subscription
     *
     * @param registry  the stream registry
     */
    TopicCacheEntry.prototype.notifyInitialSubscription = function (registry) {
        var _this = this;
        this.proxies(this.specification, registry).forEach(function (proxy) {
            proxy.onSubscription(_this.path, _this.specification);
        });
    };
    /**
     * Notify a stream of a new subscription
     *
     * @param stream  the stream to notify
     */
    TopicCacheEntry.prototype.notifySubscription = function (stream) {
        stream.onSubscription(this.path, this.specification);
        this.notifyValueToNewStream(this.path, this.specification, stream);
    };
    /**
     * Notify all streams of an unsubscription
     *
     * @param reason  the reason for unsubscribing
     * @param registry  the stream registry
     */
    TopicCacheEntry.prototype.notifyUnsubscription = function (reason, registry) {
        var _this = this;
        this.proxies(this.specification, registry).forEach(function (proxy) {
            proxy.onUnsubscription(_this.path, _this.specification, reason);
        });
    };
    /**
     * Notify a stream of a new value
     *
     * @param oldContent  the buffer containing the old content
     * @param content   the content as a Buffer
     * @param oldValue  the old value of the topic
     * @param newValue  the new value of the topic
     * @param registry  the stream registry
     */
    TopicCacheEntry.prototype.notifyValue = function (oldContent, content, oldValue, newValue, registry) {
        var _this = this;
        this.proxies(this.specification, registry).forEach(function (proxy) {
            proxy.onValue(_this.path, _this.specification, oldContent, content, oldValue, newValue);
        });
    };
    /**
     * Notify a stream of a delta event
     *
     * @param oldContent  the buffer containing the old content
     * @param content   the content as a Buffer
     * @param delta     the binary delta
     * @param oldValue  the old value of the topic
     * @param newValue  the new value of the topic
     * @param registry  the stream registry
     */
    TopicCacheEntry.prototype.notifyDelta = function (oldContent, content, delta, oldValue, newValue, registry) {
        var _this = this;
        this.proxies(this.specification, registry).forEach(function (proxy) {
            proxy.onDelta(_this.path, _this.specification, oldContent, content, delta, oldValue, newValue);
        });
    };
    /**
     * Add a new stream
     *
     * If this is the first stream, any fallback streams will be notified of an
     * unsubscription and will not receive any more updates
     *
     * @param stream    the stream to add
     * @param registry  the stream registry
     */
    TopicCacheEntry.prototype.addStream = function (stream, registry) {
        var _this = this;
        if (this.streams.length === 0) {
            registry.getFallbacks(this.specification).forEach(function (fallback) {
                fallback.onUnsubscription(_this.path, _this.specification, topics_1.UnsubscribeReasonEnum.STREAM_CHANGE);
            });
        }
        if (this.streams.indexOf(stream) < 0) {
            this.streams.push(stream);
            this.notifySubscription(stream);
        }
    };
    /**
     * Remove a stream
     *
     * If this was the last stream in the entry, any fallback streams will be notified of a
     * subscription and will receive value and delta updates.
     *
     * @param stream    the stream to remove
     * @param registry  the stream registry
     */
    TopicCacheEntry.prototype.removeStream = function (stream, registry) {
        var _this = this;
        Arrays.remove(this.streams, stream);
        if (this.streams.length === 0) {
            registry.getFallbacks(this.specification).forEach(function (fallback) {
                _this.notifySubscription(fallback);
            });
        }
    };
    /**
     * Remove all streams
     *
     * No notifications will be sent
     */
    TopicCacheEntry.prototype.removeAllStreams = function () {
        this.streams.length = 0;
    };
    return TopicCacheEntry;
}());
exports.TopicCacheEntry = TopicCacheEntry;
