"use strict";
/**
 * @module Routing
 */
Object.defineProperty(exports, "__esModule", { value: true });
var library_1 = require("core-js/library");
var Arrays = require("util/array");
var error_reason_1 = require("../../errors/error-reason");
/**
 * Internal registry for Subscription streams.
 */
var StreamRegistryImpl = /** @class */ (function () {
    /**
     * Create a new StreamRegistry instance
     *
     * @param topicCache  the topic cache
     */
    function StreamRegistryImpl(topicCache) {
        /**
         * The stream adapters organised by the topic selector
         */
        this.streams = new library_1.Map();
        /**
         * The fallback stream adapters
         */
        this.fallbacks = [];
        this.topicCache = topicCache;
    }
    /**
     * Add a stream to the registry
     *
     * @param selector  the topic selector
     * @param stream    the stream adapter to add
     */
    StreamRegistryImpl.prototype.add = function (selector, stream) {
        var existing = this.streams.get(selector);
        if (existing) {
            existing.push(stream);
        }
        else {
            this.streams.set(selector, [stream]);
        }
        this.topicCache.newStream(selector, stream, this);
        stream.onOpen();
    };
    /**
     * Add a fallback stream to the registry
     *
     * @param stream    the stream adapter to add
     */
    StreamRegistryImpl.prototype.addFallback = function (stream) {
        this.fallbacks.push(stream);
    };
    /**
     * Get the fallback stream for a given topic specification
     *
     * @param  specification  the topic specification
     * @return                an array of stream adapters that select the topic
     *                        specification
     */
    StreamRegistryImpl.prototype.getFallbacks = function (specification) {
        return this.fallbacks.filter(function (fallback) {
            return fallback.selects(specification);
        });
    };
    /**
     * Remove a stream from the registry
     *
     * @param stream    the stream adapter to remove
     */
    StreamRegistryImpl.prototype.remove = function (stream) {
        var _this = this;
        Arrays.remove(this.fallbacks, stream);
        this.streams.forEach(function (existing, selector) {
            if (Arrays.remove(existing, stream)) {
                _this.topicCache.removeStream(stream, _this);
            }
            if (existing.length === 0) {
                _this.streams.delete(selector);
            }
        });
    };
    /**
     * Get the streams for a topic path that match a topic specification
     *
     * @param  topic          the topic path
     * @param  specification  the topic specification
     * @return                an array of stream adapters that select the topic
     *                        specification
     */
    StreamRegistryImpl.prototype.streamsFor = function (topic, specification) {
        var combined = [];
        this.streams.forEach(function (existing, selector) {
            if (selector.selects(topic)) {
                combined = combined.concat(existing
                    .filter(function (stream) {
                    return stream.selects(specification);
                }).map(function (stream) {
                    return stream.adapter ? stream.adapter(specification) : stream;
                }));
            }
        });
        return combined;
    };
    /**
     * Close the stream registry
     *
     * All streams will receive an {@link ErrorReason.SESSION_CLOSED SESSION_CLOSED}
     * subscription error. No further values will be emitted.
     */
    StreamRegistryImpl.prototype.close = function () {
        // session is closing down, don't notify fallback streams of any subscription
        // from other value streams.
        this.topicCache.clear();
        this.streams.forEach(function (streamArray) {
            streamArray.forEach(function (stream) {
                stream.onSubscriptionError(error_reason_1.ErrorReason.SESSION_CLOSED);
            });
        });
        this.fallbacks.forEach(function (stream) {
            stream.onSubscriptionError(error_reason_1.ErrorReason.SESSION_CLOSED);
        });
    };
    return StreamRegistryImpl;
}());
exports.StreamRegistryImpl = StreamRegistryImpl;
