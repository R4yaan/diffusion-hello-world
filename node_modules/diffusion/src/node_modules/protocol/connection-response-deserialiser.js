"use strict";
/**
 * @module Protocol
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var buffer_input_stream_1 = require("io/buffer-input-stream");
var consts_1 = require("protocol/consts");
var response_code_1 = require("protocol/response-code");
var BEES = require("serialisers/byte-encoded-enum-serialiser");
var session_id_1 = require("session/session-id");
var session_token_deserialiser_1 = require("session/session-token-deserialiser");
var logger_1 = require("util/logger");
var log = logger_1.create('Cascading');
/**
 * The reason for throwing an error when deserialising the connection response header
 */
var DeserialisationErrorReason;
(function (DeserialisationErrorReason) {
    /**
     * The protocol byte was not recognised
     */
    DeserialisationErrorReason[DeserialisationErrorReason["UNRECOGNISED_PROTOCOL_BYTE"] = 0] = "UNRECOGNISED_PROTOCOL_BYTE";
    /**
     * The protocol versions do not match
     */
    DeserialisationErrorReason[DeserialisationErrorReason["PROTOCOL_VERSION_MISMATCH"] = 1] = "PROTOCOL_VERSION_MISMATCH";
})(DeserialisationErrorReason = exports.DeserialisationErrorReason || (exports.DeserialisationErrorReason = {}));
/**
 * An error that is thrown when there was a problem deserialising the connection
 * response header
 */
var DeserialisationError = /** @class */ (function (_super) {
    __extends(DeserialisationError, _super);
    /**
     * Create the error
     *
     * @param  message  the error message
     * @param  reason   the reason for the error
     */
    function DeserialisationError(message, reason) {
        var _this = _super.call(this, message) || this;
        _this.reason = reason;
        return _this;
    }
    return DeserialisationError;
}(Error));
exports.DeserialisationError = DeserialisationError;
/**
 * Deserialise connection responses according to the V5 protocol.
 *
 * @param buffer  the Buffer to deserialise
 */
function deserialise(buffer) {
    var input = new buffer_input_stream_1.BufferInputStream(buffer);
    var protocol = input.read();
    if (protocol !== consts_1.PROTOCOL.PROTOCOL_BYTE) {
        throw new DeserialisationError('Unrecognised protocol byte: ' + protocol, DeserialisationErrorReason.UNRECOGNISED_PROTOCOL_BYTE);
    }
    var version = input.read();
    if (version !== consts_1.PROTOCOL.CURRENT_VERSION) {
        log.debug("Server responded with protocol version " + version + ". Client version is " + consts_1.PROTOCOL.CURRENT_VERSION + ".");
        if (version < consts_1.PROTOCOL.CURRENT_VERSION) {
            throw new DeserialisationError('Unrecognised protocol version: ' + version, DeserialisationErrorReason.PROTOCOL_VERSION_MISMATCH);
        }
        else if (version > consts_1.PROTOCOL.CURRENT_VERSION) {
            throw new DeserialisationError('Unsupported protocol version: ' + version, DeserialisationErrorReason.PROTOCOL_VERSION_MISMATCH);
        }
    }
    var responseCode = BEES.read(input, response_code_1.responseCodes);
    if (response_code_1.isSuccess(responseCode)) {
        // for some reason we serialise session ids as unsigned longs here
        var sessionID = new session_id_1.SessionId(input.readUInt64(), input.readUInt64());
        var sessionToken = session_token_deserialiser_1.readSessionToken(input);
        var systemPingPeriod = input.readInt64();
        var recoverySequence = 0;
        var maximumMessageSize = -1;
        if (responseCode === response_code_1.responseCodes.RECONNECTED) {
            recoverySequence = input.readInt32();
        }
        else {
            maximumMessageSize = input.readInt32();
        }
        return {
            response: responseCode,
            identity: sessionID,
            token: sessionToken,
            systemPingPeriod: systemPingPeriod,
            version: version,
            success: true,
            sequence: recoverySequence,
            maximumMessageSize: maximumMessageSize
        };
    }
    else {
        return {
            response: responseCode,
            version: version,
            identity: null,
            token: null,
            systemPingPeriod: null,
            success: false,
            sequence: 0,
            maximumMessageSize: -1
        };
    }
}
exports.deserialise = deserialise;
