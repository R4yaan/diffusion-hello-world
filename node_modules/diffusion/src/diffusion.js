"use strict";
/**
 * @module diffusion
 */
Object.defineProperty(exports, "__esModule", { value: true });
var InternalSessionFactory = require("client/internal-session-factory");
var datatypes_1 = require("data/datatypes");
var DiffusionGlobals = require("diffusion/diffusion-globals");
var session_impl_1 = require("session/session-impl");
var update_constraint_factory_1 = require("topic-update/update-constraint-factory");
var logger = require("util/logger");
var error_reason_1 = require("./errors/error-reason");
var client_control_options_1 = require("./features/client-control-options");
var security_1 = require("./features/security");
var session_lock_options_1 = require("./features/session-lock-options");
var topic_selectors_1 = require("./selectors/topic-selectors");
var topic_update_1 = require("./topic-update/topic-update");
var topics_1 = require("./topics/topics");
logger.setLevel('warn');
/**
 * The top-level Diffusion API.
 *
 * Provides access to Session connections and global namespaces.
 */ // export namespace diffusion {
/**
 * The version of this client library in the form major.minor.patch
 */
exports.version = '6.5.0';
/**
 * The build version of this client library
 */
exports.build = '70454';
/**
 * Set the level of logging used by Diffusion. This will default to silent.
 * Log levels are strings that represent different degrees of information to
 * be logged. Available options are:
 *
 * * silent
 * * error
 * * warn
 * * info
 * * debug
 * * trace
 *
 * @param level  the log level to use
 */
function log(level) {
    // keyof typeof works only because LogLevel maps the keys onto themselves
    logger.setLevel(level);
}
exports.log = log;
/**
 * Connect to a specified Diffusion server. This will return a {@link
 * Result} that will complete successfully if a session can be connected, or
 * fail if an error was encountered.
 *
 * If the result is successful, the fulfilled handler will be called with a
 * {@link Session} instance. This session will be in a connected state and
 * may be used for subsequent API calls.
 *
 * If the result fails, the rejected handler will be called with an error
 * reason.
 *
 * If `sessionName` and `workerJs` is supplied, then the call will create a
 * shared session inside a shared WebWorker. If a shared session with that name
 * already exists, this function will return an instance of the existing
 * session. Shared sessions can only be created when running in a browser
 * environment that supports the SharedWorker. For more information regarding
 * shared sessions, see {@link connectShared}.
 *
 * **Example:**
 * ```
 * diffusion.connect('example.server.com').then(function(session) {
 *     // Connected with a session
 *     console.log('Connected!', session);
 * }, function(error) {
 *     // Connection failed
 *     console.log('Failed to connect', error);
 * });
 * ```
 *
 * @param options      the options to construct the session with. If a string is
 *                     supplied, it will be interpreted as the `host` option.
 * @param sessionName  the name of the shared session
 * @param workerJs     the location of the diffusion worker script
 * @returns            a {@link Result} for this operation
 */
function connect(options, sessionName, workerJs) {
    return session_impl_1.SessionImpl.create(InternalSessionFactory.create(sessionName, workerJs), options);
}
exports.connect = connect;
/**
 * Connect to a specified Diffusion server using a shared WebWorker session.
 * This will return a {@link Result} that will complete successfully if a
 * session can be connected, or fail if an error was encountered. Shared
 * sessions can only be created when running in a browser environment that
 * supports the SharedWorker.
 *
 * Shared sessions are identified by a name. If a shared session with that name
 * already exists, this function will return an instance of the existing
 * session. Otherwise the call will fail. Sessions can only be shared across
 * scripts originating from a single domain. Otherwise the browser will create
 * independent shared workers resulting in one shared session for each domain.
 *
 * The shared session will stay alive as long as there is an open browser tab
 * that initiated a connection through the shared session. When the last tab is
 * closed the shared worker holding the shared session will be terminated. The
 * shared session is also expected to be terminated when the only tab holding a
 * reference to the session is reloaded or experiences a page navigation. The
 * exact behavior may be browser dependent.
 *
 * The `workerJs` argument must be set to the URL of the `diffusion-worker.js`
 * supplied with the JavaScript distribution. The same-origin policy of
 * the shared worker requires the calling script and the `diffusion-worker.js`
 * to reside on the same domain.
 *
 * If the result is successful, the fulfilled handler will be called with a
 * {@link Session} instance. This session will be in a connected state and
 * may be used for subsequent API calls.
 *
 * If the result fails, the rejected handler will be called with an error
 * reason.
 *
 * **Example:**
 * ```
 * diffusion.connectShared('some-session', 'diffusion-worker.js')
 * .then(function(session) {
 *     // Connected with a session
 *     console.log('Connected!', session);
 * }, function(error) {
 *     // Connection failed
 *     console.log('Failed to connect', error);
 * });
 * ```
 *
 * @param sessionName  the name of the shared session
 * @param workerJs     the location of the diffusion worker script
 * @returns            a {@link Result} for this operation
 */
function connectShared(sessionName, workerJs) {
    return session_impl_1.SessionImpl.create(InternalSessionFactory.createShared(sessionName, workerJs), undefined);
}
exports.connectShared = connectShared;
/**
 * Escapes special characters in a string that is to be used within a topic
 * property or a session filter.
 * <P>
 * This is a convenience method which inserts an escape character '\' before
 * any of the special characters ' " or \.
 *
 * @param s  the string to be escaped
 * @returns  the string value with escape characters inserted as appropriate
 *
 * @since 6.1
 */
function escape(s) {
    return DiffusionGlobals.escape(s);
}
exports.escape = escape;
/**
 * Utility method which converts a string of the format required by the
 * {@link PropertyKeys.ROLES $Roles} session property into a mutable set of
 * strings.
 *
 * @param s  the string with quoted roles separated by whitespace or
 *           commas
 *
 * @return   set of roles
 *
 * @since 6.2
 */
function stringToRoles(s) {
    return DiffusionGlobals.stringToRoles(s);
}
exports.stringToRoles = stringToRoles;
/**
 * Utility method which converts a set of authorisation roles to the string
 * format required by the {@link PropertyKeys.ROLES $Roles} session property.
 *
 * @param roles  a set of roles
 * @return       a string representing the supplied roles, formatted as
 *               required by the {@link PropertyKeys.ROLES $Roles} session
 *               property
 *
 * @since 6.2
 */
function rolesToString(roles) {
    return DiffusionGlobals.rolesToString(roles);
}
exports.rolesToString = rolesToString;
/**
 * Returns an update constraint factory.
 *
 * @function diffusion#updateConstraints
 * @return {diffusion.topicUpdate.UpdateConstraintFactory} update constraint
 *         factory
 * @since 6.2
 */
function updateConstraints() {
    return update_constraint_factory_1.updateConstraintFactory;
}
exports.updateConstraints = updateConstraints;
/**
 * Access to the datatypes namespace
 */
exports.datatypes = datatypes_1.DataTypes;
/**
 * Access to the selectors namespace
 */
exports.selectors = new topic_selectors_1.TopicSelectors();
/**
 * Access to the topics namespace
 */
exports.topics = topics_1.topicsNamespace;
/**
 * Access to the topicUpdate namespace
 */
exports.topicUpdate = topic_update_1.TopicUpdateNamespace;
/**
 * The ErrorReason enum
 */
exports.errors = error_reason_1.ErrorReason;
/**
 * Access to PropertyKeys
 */
exports.clients = client_control_options_1.ClientControlOptions;
/**
 * Access to the locks namespace
 */
exports.locks = session_lock_options_1.SessionLockOptions;
var client_location_1 = require("./client/client-location");
exports.AddressType = client_location_1.AddressType;
var client_summary_1 = require("./client/client-summary");
exports.ClientType = client_summary_1.ClientType;
exports.TransportType = client_summary_1.TransportType;
var close_reason_1 = require("./client/close-reason");
exports.CloseReasonEnum = close_reason_1.CloseReasonEnum;
var session_details_1 = require("./client/session-details");
exports.DetailType = session_details_1.DetailType;
var client_control_1 = require("./features/client-control");
exports.SessionEventType = client_control_1.SessionEventType;
var remote_servers_1 = require("./features/remote-servers");
exports.ConnectionOption = remote_servers_1.ConnectionOption;
exports.ConnectionState = remote_servers_1.ConnectionState;
var security_2 = require("./features/security");
exports.GlobalPermission = security_2.GlobalPermission;
exports.PathPermission = security_2.PathPermission;
exports.ValidationType = security_2.ValidationType;
var session_lock_options_2 = require("./features/session-lock-options");
exports.SessionLockScope = session_lock_options_2.SessionLockScope;
var topic_notifications_1 = require("./features/topic-notifications");
exports.TopicNotificationType = topic_notifications_1.TopicNotificationType;
var topic_selector_1 = require("./selectors/topic-selector");
exports.Prefix = topic_selector_1.Prefix;
exports.Type = topic_selector_1.Type;
var topic_update_2 = require("./topic-update/topic-update");
exports.TopicCreationResult = topic_update_2.TopicCreationResult;
var logger_1 = require("./util/logger");
exports.LogLevel = logger_1.LogLevel;
/**
 * Permissions that are applied on a path
 * @deprecated since 6.5
 * Replaced by {@link PathPermission}
 */ // tslint:disable-next-line:variable-name
exports.TopicPermission = security_1.PathPermission;
